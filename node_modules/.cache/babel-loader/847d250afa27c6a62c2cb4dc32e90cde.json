{"ast":null,"code":"function sliceChunks(chunks, token) {\n  var startIndex = token.start._index;\n  var startBufferIndex = token.start._bufferIndex;\n  var endIndex = token.end._index;\n  var endBufferIndex = token.end._bufferIndex;\n  var view;\n\n  if (startIndex === endIndex) {\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];\n  } else {\n    view = chunks.slice(startIndex, endIndex);\n\n    if (startBufferIndex > -1) {\n      view[0] = view[0].slice(startBufferIndex);\n    }\n\n    if (endBufferIndex > 0) {\n      view.push(chunks[endIndex].slice(0, endBufferIndex));\n    }\n  }\n\n  return view;\n}\n\nexport default sliceChunks;","map":{"version":3,"sources":["/Users/vanshsmacpro/Desktop/Software_engineering/HIMSSE/node_modules/micromark/dist/util/slice-chunks.mjs"],"names":["sliceChunks","chunks","token","startIndex","start","_index","startBufferIndex","_bufferIndex","endIndex","end","endBufferIndex","view","slice","push"],"mappings":"AAAA,SAASA,WAAT,CAAqBC,MAArB,EAA6BC,KAA7B,EAAoC;AAClC,MAAIC,UAAU,GAAGD,KAAK,CAACE,KAAN,CAAYC,MAA7B;AACA,MAAIC,gBAAgB,GAAGJ,KAAK,CAACE,KAAN,CAAYG,YAAnC;AACA,MAAIC,QAAQ,GAAGN,KAAK,CAACO,GAAN,CAAUJ,MAAzB;AACA,MAAIK,cAAc,GAAGR,KAAK,CAACO,GAAN,CAAUF,YAA/B;AACA,MAAII,IAAJ;;AAEA,MAAIR,UAAU,KAAKK,QAAnB,EAA6B;AAC3BG,IAAAA,IAAI,GAAG,CAACV,MAAM,CAACE,UAAD,CAAN,CAAmBS,KAAnB,CAAyBN,gBAAzB,EAA2CI,cAA3C,CAAD,CAAP;AACD,GAFD,MAEO;AACLC,IAAAA,IAAI,GAAGV,MAAM,CAACW,KAAP,CAAaT,UAAb,EAAyBK,QAAzB,CAAP;;AAEA,QAAIF,gBAAgB,GAAG,CAAC,CAAxB,EAA2B;AACzBK,MAAAA,IAAI,CAAC,CAAD,CAAJ,GAAUA,IAAI,CAAC,CAAD,CAAJ,CAAQC,KAAR,CAAcN,gBAAd,CAAV;AACD;;AAED,QAAII,cAAc,GAAG,CAArB,EAAwB;AACtBC,MAAAA,IAAI,CAACE,IAAL,CAAUZ,MAAM,CAACO,QAAD,CAAN,CAAiBI,KAAjB,CAAuB,CAAvB,EAA0BF,cAA1B,CAAV;AACD;AACF;;AAED,SAAOC,IAAP;AACD;;AAED,eAAeX,WAAf","sourcesContent":["function sliceChunks(chunks, token) {\n  var startIndex = token.start._index\n  var startBufferIndex = token.start._bufferIndex\n  var endIndex = token.end._index\n  var endBufferIndex = token.end._bufferIndex\n  var view\n\n  if (startIndex === endIndex) {\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n\n    if (startBufferIndex > -1) {\n      view[0] = view[0].slice(startBufferIndex)\n    }\n\n    if (endBufferIndex > 0) {\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n\n  return view\n}\n\nexport default sliceChunks\n"]},"metadata":{},"sourceType":"module"}