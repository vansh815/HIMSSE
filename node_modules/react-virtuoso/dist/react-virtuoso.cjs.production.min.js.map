{"version":3,"file":"react-virtuoso.cjs.production.min.js","sources":["../src/VirtuosoContext.tsx","../src/tinyrx.ts","../src/EngineCommons.ts","../src/AATree.ts","../src/GroupIndexTransposer.ts","../src/engines/listEngine.ts","../src/OffsetList.ts","../src/engines/scrollSeekEngine.ts","../src/rxio.ts","../src/VirtuosoStore.tsx","../src/engines/topListEngine.ts","../src/engines/offsetListEngine.ts","../src/engines/initialItemCountEngine.ts","../src/engines/stickyItemsEngine.ts","../src/engines/groupCountEgine.ts","../src/engines/scrolledToBottomEngine.ts","../src/engines/scrollToIndexEngine.ts","../src/engines/initialTopMostItemEngine.ts","../src/engines/adjustForPrependedItemsEngine.ts","../src/engines/maxRangeSizeEngine.ts","../src/engines/topItemCountEngine.ts","../src/engines/followOutputEngine.ts","../src/Style.tsx","../src/Utils.tsx","../src/VirtuosoFiller.tsx","../src/VirtuosoList.tsx","../src/VirtuosoScroller.tsx","../src/VirtuosoView.tsx","../src/Virtuoso.tsx","../src/GroupedVirtuoso.tsx","../src/VirtuosoGridEngine.ts","../src/VirtuosoGrid.tsx"],"sourcesContent":["import { createContext } from 'react'\nimport { VirtuosoStore } from './VirtuosoStore'\n\nexport const VirtuosoContext = createContext<ReturnType<typeof VirtuosoStore> | undefined>(undefined)\n","export type TSubscriber<T> = (val: T) => void\nexport type TSubscription = () => void\nexport type TSubscribe<T> = (subscriber: TSubscriber<T>) => TSubscription\nexport type TOperator<T, K> = (val: T, done: (result: K) => void) => void\n\nexport interface TObservable<T> {\n  subscribe: TSubscribe<T>\n  pipe(...operators: []): TObservable<T>\n  pipe<R1>(...operators: [TOperator<T, R1>]): TObservable<R1>\n  pipe<R1, R2>(...operators: [TOperator<T, R1>, TOperator<R1, R2>]): TObservable<R2>\n  pipe<R1, R2, R3>(...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>]): TObservable<R3>\n  pipe<R1, R2, R3, R4>(\n    ...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>, TOperator<R3, R4>]\n  ): TObservable<R4>\n}\n\nexport interface TSubject<T> extends TObservable<T> {\n  next(val: T): void\n  subscribers: TSubscriber<T>[]\n}\n\nfunction combineOperators<A1>(): TOperator<A1, A1>\nfunction combineOperators<A1, R1>(o1: TOperator<A1, R1>): TOperator<A1, R1>\nfunction combineOperators<A1, R1, R2>(o1: TOperator<A1, R1>, o2: TOperator<R1, R2>): TOperator<A1, R2>\nfunction combineOperators<A1, R1, R2>(o1: TOperator<A1, R1>, o2: TOperator<R1, R2>): TOperator<A1, R2>\nfunction combineOperators<A1, R1, R2, R3>(\n  o1: TOperator<A1, R1>,\n  o2: TOperator<R1, R2>,\n  o3: TOperator<R2, R3>\n): TOperator<A1, R3>\nfunction combineOperators<A1, R1, R2, R3, R4>(\n  o1: TOperator<A1, R1>,\n  o2: TOperator<R1, R2>,\n  o3: TOperator<R2, R3>,\n  o4: TOperator<R3, R4>\n): TOperator<A1, R4>\nfunction combineOperators<T>(...operators: TOperator<any, any>[]): TOperator<T, any>\nfunction combineOperators<T, K>(...operators: TOperator<any, any>[]) {\n  if (operators.length === 0) {\n    return (value: T, subscriber: (value: T) => void) => subscriber(value)\n  }\n  if (operators.length === 1) {\n    return operators[0]\n  }\n\n  return (value: T, subscriber: (value: K) => void): void => {\n    let acc = (value: any) => subscriber(value)\n    operators\n      .slice()\n      .reverse()\n      .forEach(operator => {\n        const prevCallback = acc\n        acc = value => operator(value, prevCallback)\n      })\n    acc(value)\n  }\n}\n\nfunction buildPipe<T>(subscribe: TSubscribe<T>) {\n  function pipe(...operators: []): TObservable<T>\n  function pipe<R1>(...operators: [TOperator<T, R1>]): TObservable<R1>\n  function pipe<R1, R2>(...operators: [TOperator<T, R1>, TOperator<R1, R2>]): TObservable<R2>\n  function pipe<R1, R2, R3>(...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>]): TObservable<R3>\n  function pipe<R1, R2, R3, R4>(\n    ...operators: [TOperator<T, R1>, TOperator<R1, R2>, TOperator<R2, R3>, TOperator<R3, R4>]\n  ): TObservable<R4>\n  function pipe<K extends TOperator<any, any>[]>(...operators: K) {\n    const operator = combineOperators(...operators)\n    return observable(subscribe, operator)\n  }\n  return pipe\n}\n\nexport function observable<T, K>(source: TSubscribe<T>, operator: TOperator<T, K>) {\n  const subscribe = (subscriber: TSubscriber<K>) => {\n    return source(val => operator(val, subscriber))\n  }\n\n  return {\n    subscribe,\n    pipe: buildPipe(subscribe),\n  }\n}\n\nexport function subject<T>(initial?: T, distinct = true): TSubject<T> {\n  let subscribers: TSubscriber<T>[] = []\n  let val: T | undefined = initial\n\n  const next = (newVal: T) => {\n    if (!distinct || newVal !== val) {\n      val = newVal\n      subscribers.forEach(subscriber => subscriber(newVal))\n    }\n  }\n\n  const subscribe = (subscriber: TSubscriber<T>) => {\n    subscribers.push(subscriber)\n    if (val !== undefined) {\n      subscriber(val)\n    }\n    return () => {\n      subscribers = subscribers.filter(sub => sub !== subscriber)\n    }\n  }\n\n  return {\n    next,\n    subscribe,\n    pipe: buildPipe(subscribe),\n    subscribers,\n  }\n}\n\nexport function coldSubject<T>(): TSubject<T> {\n  let subscribers: TSubscriber<T>[] = []\n\n  const next = (newVal: T) => {\n    subscribers.forEach(subscriber => subscriber(newVal))\n  }\n\n  const subscribe = (subscriber: TSubscriber<T>) => {\n    subscribers.push(subscriber)\n    return () => {\n      subscribers = subscribers.filter(sub => sub !== subscriber)\n    }\n  }\n\n  return {\n    next,\n    subscribe,\n    pipe: buildPipe(subscribe),\n    subscribers,\n  }\n}\n\nexport function combineLatest<S1, S2>(s1: TObservable<S1>, s2: TObservable<S2>): TObservable<[S1, S2]>\nexport function combineLatest<S1, S2, S3>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>\n): TObservable<[S1, S2, S3]>\nexport function combineLatest<S1, S2, S3, S4>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>\n): TObservable<[S1, S2, S3, S4]>\nexport function combineLatest<S1, S2, S3, S4, S5>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>\n): TObservable<[S1, S2, S3, S4, S5]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6>(\n  ...s: [TObservable<S1>, TObservable<S2>, TObservable<S3>, TObservable<S4>, TObservable<S5>, TObservable<S6>]\n): TObservable<[S1, S2, S3, S4, S5, S6]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8, S9>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>,\n  s9: TObservable<S9>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8, S9]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>,\n  s9: TObservable<S9>,\n  s10: TObservable<S10>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8, S9, S10]>\nexport function combineLatest<S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11>(\n  s1: TObservable<S1>,\n  s2: TObservable<S2>,\n  s3: TObservable<S3>,\n  s4: TObservable<S4>,\n  s5: TObservable<S5>,\n  s6: TObservable<S6>,\n  s7: TObservable<S7>,\n  s8: TObservable<S8>,\n  s9: TObservable<S9>,\n  s10: TObservable<S10>,\n  s11: TObservable<S11>\n): TObservable<[S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11]>\nexport function combineLatest(...sources: TObservable<any>[]): TObservable<any[]> {\n  const called = Array<boolean>(sources.length).fill(false)\n  const values = Array<any>(sources.length)\n  let subscribers: TSubscriber<any>[] = []\n\n  const publish = (subscribers: TSubscriber<any>[]) => {\n    called.every(isCalled => isCalled) && subscribers.forEach(subscriber => subscriber(values))\n  }\n\n  sources.forEach((source, index) => {\n    source.subscribe(val => {\n      called[index] = true\n      values[index] = val\n      publish(subscribers)\n    })\n  })\n\n  const subscribe = (subscriber: TSubscriber<any[]>) => {\n    subscribers.push(subscriber)\n    publish([subscriber])\n    return () => {\n      subscribers = subscribers.filter(sub => sub !== subscriber)\n    }\n  }\n\n  return { subscribe, pipe: buildPipe(subscribe) }\n}\n\nexport function map<T, K>(map: (val: T) => K): (val: T, subscriber: TSubscriber<K>) => void {\n  return (val: T, subscriber: TSubscriber<K>) => {\n    subscriber(map(val))\n  }\n}\n\nexport function mapTo<T>(val: T) {\n  return (_: any, done: TSubscriber<T>) => done(val)\n}\n\nexport function skip<T>(times: number) {\n  return (val: T, done: TSubscriber<T>) => {\n    if (times > 0) {\n      times--\n    } else {\n      done(val)\n    }\n  }\n}\n\nexport function filter<T>(predicate: (val: T) => boolean) {\n  return (val: T, done: TSubscriber<T>) => {\n    predicate(val) && done(val)\n  }\n}\n\nexport function duc<T>(comparator = (current: T, next: T) => current !== next) {\n  let current: T\n  return (next: T, done: TSubscriber<T>) => {\n    if (comparator(current, next)) {\n      current = next\n      done(next)\n    }\n  }\n}\n\nexport function debounceTime<T>(time: number) {\n  let val: T | undefined\n  let timeout: any\n\n  return (newVal: T, done: TSubscriber<T>) => {\n    val = newVal\n    if (timeout) {\n      clearTimeout(timeout)\n    }\n\n    timeout = setTimeout(() => {\n      done(val!)\n    }, time)\n  }\n}\n\nexport function throttleTime<T>(time: number) {\n  let val: T | undefined\n  let timeout: any\n\n  return (newVal: T, done: TSubscriber<T>) => {\n    val = newVal\n\n    if (timeout) {\n      return\n    }\n\n    timeout = setTimeout(() => {\n      timeout = undefined\n      done(val!)\n    }, time)\n  }\n}\n\nexport function scan<T, K>(scanner: (prevVal: T, current: K) => T, initialValue: T) {\n  let prevVal: T = initialValue\n  return (newVal: K, done: TSubscriber<T>) => {\n    done((prevVal = scanner(prevVal, newVal)))\n  }\n}\n\nexport function withLatestFrom<T, R1>(s1: TObservable<R1>): (val: T, done: TSubscriber<[T, R1]>) => void\nexport function withLatestFrom<T, R1, R2>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>\n): (val: T, done: TSubscriber<[T, R1, R2]>) => void\nexport function withLatestFrom<T, R1, R2, R3>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>\n): (val: T, done: TSubscriber<[T, R1, R2, R3]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4, R5>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>,\n  s5: TObservable<R5>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4, R5]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>,\n  s5: TObservable<R5>,\n  s6: TObservable<R6>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4, R5, R6]>) => void\nexport function withLatestFrom<T, R1, R2, R3, R4, R5, R6, R7>(\n  s1: TObservable<R1>,\n  s2: TObservable<R2>,\n  s3: TObservable<R3>,\n  s4: TObservable<R4>,\n  s5: TObservable<R5>,\n  s6: TObservable<R6>,\n  s7: TObservable<R7>\n): (val: T, done: TSubscriber<[T, R1, R2, R3, R4, R5, R6, R7]>) => void\n\nexport function withLatestFrom<T>(...sources: TObservable<any>[]) {\n  const called = Array<boolean>(sources.length).fill(false)\n  const values = Array<any>(sources.length)\n  sources.forEach((source, index) => {\n    source.subscribe(val => {\n      values[index] = val\n      called[index] = true\n    })\n  })\n\n  return (val: T, done: TSubscriber<any>) => {\n    called.every(isCalled => isCalled) && done([val, ...values])\n  }\n}\n","import * as React from 'react'\nimport { debounceTime, mapTo, skip, subject, TObservable, duc } from './tinyrx'\n\ninterface TScrollLocationWithAlign {\n  index: number\n  align: 'start' | 'center' | 'end'\n  behavior?: 'smooth' | 'auto'\n}\n\nexport type TScrollLocation = number | TScrollLocationWithAlign\n\nexport type TContainer =\n  | React.ComponentType<{ className: string; style?: React.CSSProperties; key?: number }>\n  | keyof JSX.IntrinsicElements\n\nexport const buildIsScrolling = (scrollTop$: TObservable<number>): TObservable<boolean> => {\n  const isScrolling$ = subject(false)\n\n  scrollTop$.pipe(skip(1), duc(), mapTo(true)).subscribe(isScrolling$.next)\n\n  scrollTop$.pipe(skip(1), mapTo(false), debounceTime(200)).subscribe(isScrolling$.next)\n\n  return isScrolling$\n}\n","interface NodeData<T> {\n  key: number\n  value: T\n}\n\ninterface Range<T> {\n  start: number\n  end: number\n  value: T\n}\n\ntype FindCallback<T> = (value: T) => 1 | 0 | -1\n\nexport type NodeIterator<T> = IterableIterator<NodeData<T>>\nexport type RangeIterator<T> = IterableIterator<Range<T>>\n\nclass NilNode<T> {\n  public level = 0\n\n  public rebalance(): this {\n    return this\n  }\n\n  public adjust(): this {\n    return this\n  }\n\n  public shift(): this {\n    return this\n  }\n\n  public remove(): this {\n    return this\n  }\n\n  public find(): undefined {\n    return\n  }\n\n  public findWith(): undefined {\n    return\n  }\n\n  public findMax(): number {\n    return -Infinity\n  }\n\n  public findMaxValue(): undefined {\n    return\n  }\n\n  public insert(key: number, value: T): NonNilNode<T> {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new NonNilNode<T>({ key, value, level: 1 })\n  }\n\n  public walkWithin(): NodeData<T>[] {\n    return []\n  }\n\n  public walk(): NodeData<T>[] {\n    return []\n  }\n\n  public ranges<T>(): Range<T>[] {\n    return []\n  }\n\n  public rangesWithin<T>(): Range<T>[] {\n    return []\n  }\n\n  public empty(): this is NilNode<T> {\n    return true\n  }\n\n  public isSingle(): true {\n    return true\n  }\n\n  public isInvariant(): true {\n    return true\n  }\n\n  public keys(): number[] {\n    return []\n  }\n}\n\nconst NIL_NODE = new NilNode()\n\nObject.freeze(NIL_NODE)\n\ntype Node<T> = NonNilNode<T> | NilNode<T>\n\ninterface NodeConstructorArgs<T> {\n  key: number\n  value: T\n  level: number\n  left?: Node<T>\n  right?: Node<T>\n}\n\nclass UnreachableCaseError extends Error {\n  constructor(val: never) {\n    super(`Unreachable case: ${val}`)\n  }\n}\n\nclass NonNilNode<T> {\n  public key: number\n  public value: T\n  public level: number\n  public left: Node<T>\n  public right: Node<T>\n\n  public constructor({\n    key,\n    value,\n    level,\n    left = NIL_NODE as NilNode<T>,\n    right = NIL_NODE as NilNode<T>,\n  }: NodeConstructorArgs<T>) {\n    this.key = key\n    this.value = value\n    this.level = level\n    this.left = left\n    this.right = right\n  }\n\n  public shift(amount: number): Node<T> {\n    return this.clone({\n      key: this.key + amount,\n      left: this.left.shift(amount),\n      right: this.right.shift(amount),\n    })\n  }\n\n  public remove(key: number): Node<T> {\n    const { left, right } = this\n\n    if (key === this.key) {\n      if (left.empty()) {\n        return right\n      } else if (right.empty()) {\n        return left\n      } else {\n        const [lastKey, lastValue] = left.last()\n        return this.clone({\n          key: lastKey,\n          value: lastValue,\n          left: left.deleteLast(),\n        }).adjust()\n      }\n    } else if (key < this.key) {\n      return this.clone({\n        left: left.remove(key),\n      }).adjust()\n    } else {\n      return this.clone({\n        right: right.remove(key),\n      }).adjust()\n    }\n  }\n\n  public empty(): this is NilNode<T> {\n    return false\n  }\n\n  public find(key: number): T | undefined {\n    if (key === this.key) {\n      return this.value\n    } else if (key < this.key) {\n      return this.left.find(key)\n    } else {\n      return this.right.find(key)\n    }\n  }\n\n  public findWith(callback: FindCallback<T>): [number, T] | undefined {\n    const result = callback(this.value)\n\n    switch (result) {\n      case -1:\n        return this.left.findWith(callback)\n      case 0:\n        return [this.key, this.value]\n      case 1:\n        return this.right.findWith(callback)\n      default:\n        throw new UnreachableCaseError(result)\n    }\n  }\n\n  public findMax(key: number): number {\n    if (this.key === key) {\n      return key\n    }\n\n    if (this.key < key) {\n      const rightKey = this.right.findMax(key)\n      if (rightKey === -Infinity) {\n        return this.key\n      } else {\n        return rightKey\n      }\n    }\n\n    return this.left.findMax(key)\n  }\n\n  public findMaxValue(key: number): T {\n    if (this.key === key) {\n      return this.value\n    }\n\n    if (this.key < key) {\n      const rightValue = this.right.findMaxValue(key)\n      if (rightValue === undefined) {\n        return this.value\n      } else {\n        return rightValue\n      }\n    }\n\n    return this.left.findMaxValue(key)!\n  }\n\n  public insert(key: number, value: T): NonNilNode<T> {\n    if (key === this.key) {\n      return this.clone({ key, value })\n    } else if (key < this.key) {\n      return this.clone({\n        left: this.left.insert(key, value),\n      }).rebalance()\n    } else {\n      return this.clone({\n        right: this.right.insert(key, value),\n      }).rebalance()\n    }\n  }\n\n  public walkWithin(start: number, end: number): NodeData<T>[] {\n    const { key, value } = this\n    let result: NodeData<T>[] = []\n    if (key > start) {\n      result = result.concat(this.left.walkWithin(start, end))\n    }\n\n    if (key >= start && key <= end) {\n      result.push({ key, value })\n    }\n\n    if (key <= end) {\n      result = result.concat(this.right.walkWithin(start, end))\n    }\n\n    return result\n  }\n\n  public walk(): NodeData<T>[] {\n    return [...this.left.walk(), { key: this.key, value: this.value }, ...this.right.walk()]\n  }\n\n  public last(): [number, T] {\n    if (this.right.empty()) {\n      return [this.key, this.value]\n    } else {\n      return this.right.last()\n    }\n  }\n\n  public deleteLast(): Node<T> {\n    if (this.right.empty()) {\n      return this.left\n    } else {\n      return this.clone({\n        right: this.right.deleteLast(),\n      }).adjust()\n    }\n  }\n\n  public clone(args: Partial<NodeConstructorArgs<T>>): NonNilNode<T> {\n    return new NonNilNode<T>({\n      key: args.key !== undefined ? args.key : this.key,\n      value: args.value !== undefined ? args.value : this.value,\n      level: args.level !== undefined ? args.level : this.level,\n      left: args.left !== undefined ? args.left : this.left,\n      right: args.right !== undefined ? args.right : this.right,\n    })\n  }\n\n  public isSingle(): boolean {\n    return this.level > this.right.level\n  }\n\n  public rebalance(): NonNilNode<T> {\n    return this.skew().split()\n  }\n\n  public adjust(): NonNilNode<T> {\n    const { left, right, level } = this\n    if (right.level >= level - 1 && left.level >= level - 1) {\n      return this\n    } else if (level > right.level + 1) {\n      if (left.isSingle()) {\n        return this.clone({ level: level - 1 }).skew()\n      } else {\n        if (!left.empty() && !left.right.empty()) {\n          return left.right.clone({\n            left: left.clone({ right: left.right.left }),\n            right: this.clone({\n              left: left.right.right,\n              level: level - 1,\n            }),\n            level: level,\n          })\n        } else {\n          throw new Error('Unexpected empty nodes')\n        }\n      }\n    } else {\n      if (this.isSingle()) {\n        return this.clone({ level: level - 1 }).split()\n      } else {\n        if (!right.empty() && !right.left.empty()) {\n          const rl = right.left\n          const rightLevel = rl.isSingle() ? right.level - 1 : right.level\n\n          return rl.clone({\n            left: this.clone({\n              right: rl.left,\n              level: level - 1,\n            }),\n            right: right.clone({ left: rl.right, level: rightLevel }).split(),\n            level: rl.level + 1,\n          })\n        } else {\n          throw new Error('Unexpected empty nodes')\n        }\n      }\n    }\n  }\n\n  public isInvariant(): boolean {\n    const { left, right, level } = this\n\n    if (level !== left.level + 1) {\n      return false\n    } else if (level !== right.level && level !== right.level + 1) {\n      return false\n    } else if (!right.empty() && level <= right.right.level) {\n      return false\n    } else {\n      return left.isInvariant() && right.isInvariant()\n    }\n  }\n\n  public keys(): number[] {\n    return [...this.left.keys(), this.key, ...this.right.keys()]\n  }\n\n  public ranges(): Range<T>[] {\n    return this.toRanges(this.walk())\n  }\n\n  public rangesWithin(startIndex: number, endIndex: number): Range<T>[] {\n    return this.toRanges(this.walkWithin(startIndex, endIndex))\n  }\n\n  private toRanges(nodes: NodeData<T>[]): Range<T>[] {\n    if (nodes.length === 0) {\n      return []\n    }\n\n    const first = nodes[0]\n\n    let { key: start, value } = first\n\n    const result = []\n\n    for (let i = 1; i <= nodes.length; i++) {\n      const nextNode = nodes[i]\n      const end = nextNode ? nextNode.key - 1 : Infinity\n      result.push({ start, end, value })\n\n      if (nextNode) {\n        start = nextNode.key\n        value = nextNode.value\n      }\n    }\n    return result\n  }\n\n  private split(): NonNilNode<T> {\n    const { right, level } = this\n    if (!right.empty() && !right.right.empty() && right.level === level && right.right.level === level) {\n      return right.clone({\n        left: this.clone({ right: right.left }),\n        level: level + 1,\n      })\n    } else {\n      return this\n    }\n  }\n\n  private skew(): NonNilNode<T> {\n    const { left } = this\n\n    if (!left.empty() && left.level === this.level) {\n      return left.clone({\n        right: this.clone({ left: left.right }),\n      })\n    } else {\n      return this\n    }\n  }\n}\n\nexport class AATree<T> {\n  private root: Node<T>\n\n  public static empty<T>(): AATree<T> {\n    return new AATree<T>(NIL_NODE as NilNode<T>)\n  }\n\n  private constructor(root: Node<T>) {\n    this.root = root\n  }\n\n  public find(key: number): T | undefined {\n    return this.root.find(key)\n  }\n\n  public findMax(key: number): number {\n    return this.root.findMax(key)\n  }\n\n  public findMaxValue(key: number): T {\n    if (this.empty()) {\n      throw new Error('Searching for max value in an empty tree')\n    }\n    return this.root.findMaxValue(key)!\n  }\n\n  public findWith(callback: FindCallback<T>): [number, T] | void {\n    return this.root.findWith(callback)\n  }\n\n  public insert(key: number, value: T): AATree<T> {\n    return new AATree(this.root.insert(key, value))\n  }\n\n  public remove(key: number): AATree<T> {\n    return new AATree(this.root.remove(key))\n  }\n\n  public shift(amount: number) {\n    if (this.empty()) {\n      return this\n    }\n    const defaultValue = this.root.findMaxValue(Infinity)\n    return new AATree(this.root.shift(amount).insert(0, defaultValue!))\n  }\n\n  public empty() {\n    return this.root.empty()\n  }\n\n  public keys(): number[] {\n    return this.root.keys()\n  }\n\n  public walk(): NodeData<T>[] {\n    return this.root.walk()\n  }\n\n  public walkWithin(start: number, end: number): NodeData<T>[] {\n    const adjustedStart = this.root.findMax(start)\n    return this.root.walkWithin(adjustedStart, end)\n  }\n\n  public ranges(): Range<T>[] {\n    return this.root.ranges()\n  }\n\n  public rangesWithin(start: number, end: number): Range<T>[] {\n    const adjustedStart = this.root.findMax(start)\n    return this.root.rangesWithin(adjustedStart, end)\n  }\n\n  public isInvariant(): boolean {\n    return this.root.isInvariant()\n  }\n}\n","import { AATree } from './AATree'\nimport { Item } from './OffsetList'\n\nexport interface RecordItem extends Item {\n  type: 'item'\n  transposedIndex: number\n  groupIndex: number\n}\n\nexport interface GroupItem extends Item {\n  type: 'group'\n  groupIndex: number\n}\n\nexport type ListItem = RecordItem | GroupItem\n\nexport class StubIndexTransposer {\n  public transpose(items: Item[]): RecordItem[] {\n    return items.map(item => {\n      return {\n        groupIndex: 0,\n        index: item.index,\n        offset: item.offset,\n        size: item.size,\n        transposedIndex: item.index,\n        type: 'item',\n      }\n    })\n  }\n}\n\nexport class GroupIndexTransposer {\n  public tree: AATree<[number, number]>\n  private count: number\n\n  public constructor(counts: number[]) {\n    this.count = counts.reduce((acc, groupCount) => acc + groupCount + 1, 0)\n    let tree = AATree.empty<[number, number]>()\n    let groupIndex = 0\n    let total = 0\n    for (const groupCount of counts) {\n      tree = tree.insert(total, [groupIndex, total])\n      groupIndex++\n      total += groupCount + 1\n    }\n    this.tree = tree\n  }\n\n  public totalCount(): number {\n    return this.count\n  }\n\n  public transpose(items: Item[]): ListItem[] {\n    return items.map(item => {\n      const groupMatch = this.tree.find(item.index)\n      if (groupMatch) {\n        return {\n          groupIndex: groupMatch[0],\n          index: item.index,\n          offset: item.offset,\n          size: item.size,\n          type: 'group',\n        }\n      }\n\n      const [groupIndex] = this.tree.findMaxValue(item.index)!\n      return {\n        groupIndex: groupIndex,\n        index: item.index,\n        offset: item.offset,\n        size: item.size,\n        transposedIndex: item.index - groupIndex - 1,\n        type: 'item',\n      }\n    })\n  }\n\n  public groupIndices() {\n    return this.tree.keys()\n  }\n}\n\nexport type Transposer = StubIndexTransposer | GroupIndexTransposer\n","import { scan, combineLatest, TObservable, map, subject, withLatestFrom, coldSubject, duc } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { ListItem, Transposer } from '../GroupIndexTransposer'\n\nexport const getListTop = (items: ListItem[]) => (items.length > 0 ? items[0].offset : 0)\n\ninterface ListEngineParams {\n  overscan: number\n  defaultItemHeight?: number\n  viewportHeight$: TObservable<number>\n  scrollTop$: TObservable<number>\n  topListHeight$: TObservable<number>\n  headerHeight$: TObservable<number>\n  footerHeight$: TObservable<number>\n  minListIndex$: TObservable<number>\n  totalCount$: TObservable<number>\n  offsetList$: TObservable<OffsetList>\n  scrolledToTopMostItem$: TObservable<boolean>\n  transposer$: TObservable<Transposer>\n  totalHeight$: TObservable<number>\n}\n\nexport function listEngine({\n  overscan,\n  defaultItemHeight,\n  viewportHeight$,\n  scrollTop$,\n  topListHeight$,\n  headerHeight$,\n  footerHeight$,\n  minListIndex$,\n  totalCount$,\n  offsetList$,\n  scrolledToTopMostItem$,\n  transposer$,\n  totalHeight$,\n}: ListEngineParams) {\n  const listHeight$ = subject(0)\n  const startReached$ = coldSubject<number>()\n  const endReached$ = coldSubject<number>()\n  const list$ = subject<ListItem[]>([])\n\n  const constrainedScrollTop$ = subject(0)\n\n  combineLatest(scrollTop$, totalHeight$, viewportHeight$)\n    .pipe(\n      map(([scrollTop, totalHeight, viewportHeight]) => Math.max(0, Math.min(scrollTop, totalHeight - viewportHeight)))\n    )\n    .subscribe(constrainedScrollTop$.next)\n\n  combineLatest(\n    viewportHeight$,\n    constrainedScrollTop$,\n    topListHeight$,\n    listHeight$,\n    headerHeight$,\n    footerHeight$,\n    minListIndex$,\n    totalCount$,\n    offsetList$,\n    scrolledToTopMostItem$,\n    transposer$\n  )\n    .pipe(\n      scan(\n        (\n          items,\n          [\n            viewportHeight,\n            scrollTop,\n            topListHeight,\n            listHeight,\n            headerHeight,\n            footerHeight,\n            minIndex,\n            totalCount,\n            offsetList,\n            scrolledToTopMostItem,\n            transposer,\n          ]\n        ) => {\n          const itemLength = items.length\n\n          if (totalCount === 0) {\n            return []\n          }\n\n          const listTop = getListTop(items)\n\n          const listBottom = listTop - scrollTop + listHeight - headerHeight - footerHeight - topListHeight\n          const maxIndex = Math.max(totalCount - 1, 0)\n          const indexOutOfAllowedRange =\n            itemLength > 0 && (items[0].index < minIndex || items[itemLength - 1].index > maxIndex)\n\n          if (listBottom < viewportHeight || indexOutOfAllowedRange) {\n            const endOffset = scrollTop + viewportHeight + overscan * 2 - 1\n            items = transposer.transpose(offsetList.range(scrollTop, endOffset, minIndex, maxIndex))\n          }\n\n          if (listTop > scrollTop) {\n            const startOffset = Math.max(scrollTop - overscan * 2, 0)\n            const endOffset = scrollTop + viewportHeight - 1\n            items = transposer.transpose(offsetList.range(startOffset, endOffset, minIndex, maxIndex))\n          }\n\n          // this is a hack - we should let the probe item render,\n          // but skip the real list until the viewport has scrolled\n          // to the expected location\n          // However, if we have default item height set then we can skip this.\n          if (items.length > 1 && !scrolledToTopMostItem && !defaultItemHeight) {\n            return []\n          }\n\n          return items\n        },\n        [] as ListItem[]\n      ),\n      duc()\n    )\n    .subscribe(list$.next)\n\n  const listOffset$ = combineLatest(list$, scrollTop$, topListHeight$).pipe(map(([items]) => getListTop(items)))\n\n  constrainedScrollTop$.subscribe(scrollTop => {\n    if (scrollTop === 0) {\n      startReached$.next(scrollTop)\n    }\n  })\n\n  let currentEndIndex = 0\n\n  list$\n    .pipe(map(items => (items.length ? items[items.length - 1].index : 0)))\n    .pipe(withLatestFrom(totalCount$))\n    .subscribe(([endIndex, totalCount]) => {\n      if (totalCount === 0) {\n        return\n      }\n\n      if (endIndex === totalCount - 1) {\n        if (currentEndIndex !== endIndex) {\n          currentEndIndex = endIndex\n          endReached$.next(endIndex)\n        }\n      }\n    })\n\n  return { list$, listOffset$, listHeight$, startReached$, endReached$ }\n}\n","import { AATree } from './AATree'\n\ninterface OffsetValue {\n  startIndex: number\n  endIndex: number\n  size: number\n}\n\nexport interface Item {\n  index: number\n  offset: number\n  size: number\n}\n\nexport class OffsetList {\n  public rangeTree: AATree<number>\n  public offsetTree: AATree<OffsetValue>\n  private nanIndices: number[]\n  private initialTopMostItemIndex = 0\n  private rangeSize = 0\n  private maxRangeSize = Infinity\n  private rangeSizeExceededCallback: () => void = () => {}\n\n  public static create(): OffsetList {\n    return new OffsetList(AATree.empty<number>())\n  }\n\n  private constructor(\n    rangeTree: AATree<number>,\n    offsetTree = AATree.empty<OffsetValue>(),\n    nanIndices: number[] = [],\n    initialTopMostItemIndex = 0\n  ) {\n    this.rangeTree = rangeTree\n    this.nanIndices = nanIndices\n    this.initialTopMostItemIndex = initialTopMostItemIndex\n\n    if (offsetTree.empty()) {\n      let offset = 0\n      const ranges = rangeTree.ranges()\n\n      let nanFound = false\n\n      for (const { start: startIndex, end: endIndex, value: size } of ranges) {\n        this.rangeSize++\n        if (isNaN(size)) {\n          this.nanIndices.push(startIndex)\n\n          if (!nanFound) {\n            offsetTree = offsetTree.insert(offset, {\n              startIndex,\n              endIndex: Infinity,\n              size,\n            })\n          }\n\n          nanFound = true\n        } else if (!nanFound) {\n          offsetTree = offsetTree.insert(offset, {\n            startIndex,\n            endIndex: endIndex,\n            size,\n          })\n\n          offset += (endIndex - startIndex + 1) * size\n        }\n      }\n    }\n\n    this.offsetTree = offsetTree\n  }\n\n  public empty() {\n    return this.rangeTree.empty()\n  }\n\n  private fromTree(tree: AATree<number>) {\n    return new OffsetList(tree, undefined, undefined, this.initialTopMostItemIndex)\n  }\n\n  public insert(start: number, end: number, size: number): OffsetList {\n    let tree = this.rangeTree\n    if (tree.empty()) {\n      return this.fromTree(tree.insert(0, size))\n    }\n\n    if (this.rangeSize > this.maxRangeSize) {\n      this.rangeSizeExceededCallback()\n      return this.fromTree(AATree.empty<number>().insert(0, this.getDefaultSize()))\n    }\n\n    // tree is in non-complete state - we know the group sizes, but not the item sizes\n    if (this.nanIndices.length && this.nanIndices.indexOf(end) > -1) {\n      const groupSize = tree.find(this.nanIndices[0] - 1)\n\n      if (groupSize === size) {\n        return this.fromTree(AATree.empty<number>().insert(0, size))\n      }\n      for (const nanIndex of this.nanIndices) {\n        tree = tree.insert(nanIndex, size)\n      }\n\n      return this.fromTree(tree)\n    }\n\n    // extend the range in both directions, so that we can get adjacent neighbours.\n    // if the previous / next ones have the same value as the one we are about to insert,\n    // we 'merge' them.\n    const overlapingRanges = tree.rangesWithin(start - 1, end + 1)\n\n    if (\n      overlapingRanges.some(range => {\n        return range.start === start && (range.end === end || range.end === Infinity) && range.value === size\n      })\n    ) {\n      return this\n    }\n\n    let firstPassDone = false\n    let shouldInsert = false\n    for (const { start: rangeStart, end: rangeEnd, value: rangeValue } of overlapingRanges) {\n      // previous range\n      if (!firstPassDone) {\n        shouldInsert = rangeValue !== size\n        firstPassDone = true\n      } else {\n        // remove the range if it starts within the new range OR if\n        // it has the same value as it, in order to perfrom a merge\n        if (end >= rangeStart || size === rangeValue) {\n          tree = tree.remove(rangeStart)\n        }\n      }\n\n      // next range\n      if (rangeEnd > end && end >= rangeStart) {\n        if (rangeValue !== size && !isNaN(rangeValue)) {\n          tree = tree.insert(end + 1, rangeValue)\n        }\n      }\n    }\n\n    if (shouldInsert) {\n      tree = tree.insert(start, size)\n    }\n\n    return tree === this.rangeTree ? this : this.fromTree(tree)\n  }\n\n  public insertSpots(spotIndexes: number[], value: number): OffsetList {\n    if (this.empty()) {\n      let tree = this.rangeTree\n      for (const spot of spotIndexes) {\n        tree = tree.insert(spot, value).insert(spot + 1, NaN)\n      }\n\n      return new OffsetList(tree)\n    } else {\n      throw new Error('attempting to overwrite non-empty tree')\n    }\n  }\n\n  public offsetOf(index: number): number {\n    if (this.offsetTree.empty()) {\n      return 0\n    }\n\n    const find = (value: OffsetValue) => {\n      if (value.startIndex > index) return -1\n      if (value.endIndex < index) return 1\n      return 0\n    }\n\n    const offsetRange = this.offsetTree.findWith(find)\n    if (offsetRange) {\n      const [offset, { startIndex, size }] = offsetRange\n      return offset + (index - startIndex) * size\n    } else {\n      throw new Error(`Requested offset outside of the known ones, index: ${index}`)\n    }\n  }\n\n  public itemAt(index: number): Item {\n    const size = this.rangeTree.findMaxValue(index)\n    return { index, size, offset: NaN }\n  }\n\n  public indexRange(startIndex: number, endIndex: number): Item[] {\n    if (this.rangeTree.empty()) {\n      return [{ index: this.initialTopMostItemIndex, size: 0, offset: NaN }]\n    }\n\n    const ranges = this.rangeTree.rangesWithin(startIndex, endIndex)\n    const result: Item[] = []\n\n    for (const range of ranges) {\n      const start = Math.max(startIndex, range.start)\n      const rangeEnd = typeof range.end === 'undefined' ? Infinity : range.end\n      const end = Math.min(endIndex, rangeEnd)\n\n      for (let i = start; i <= end; i++) {\n        result.push({ index: i, size: range.value, offset: NaN })\n      }\n    }\n    return result\n  }\n\n  public range(startOffset: number, endOffset: number, minIndex = 0, maxIndex = Infinity): Item[] {\n    if (this.offsetTree.empty()) {\n      return [{ index: this.initialTopMostItemIndex, size: 0, offset: 0 }]\n    }\n\n    const ranges = this.offsetTree.rangesWithin(startOffset, endOffset)\n\n    const result: Item[] = []\n\n    for (let {\n      start: rangeOffset,\n      value: { startIndex: rangeIndex, endIndex, size },\n    } of ranges) {\n      let offset = rangeOffset\n      let startIndex = rangeIndex\n\n      if (rangeOffset < startOffset) {\n        startIndex += Math.floor((startOffset - rangeOffset) / size)\n        offset += (startIndex - rangeIndex) * size\n      }\n\n      if (startIndex < minIndex) {\n        offset += (minIndex - startIndex) * size\n        startIndex = minIndex\n      }\n\n      // we don't know the size of this range - terminate with a probe item\n      if (isNaN(size)) {\n        result.push({ index: startIndex, size: 0, offset })\n        return result\n      }\n\n      endIndex = Math.min(endIndex, maxIndex)\n\n      for (let i = startIndex; i <= endIndex; i++) {\n        if (offset > endOffset) {\n          break\n        }\n\n        result.push({ index: i, size, offset })\n        offset += size\n      }\n    }\n    return result\n  }\n\n  public total(endIndex: number) {\n    const ranges = this.rangeTree.rangesWithin(0, endIndex)\n\n    let total = 0\n\n    for (let { start, end, value: size } of ranges) {\n      end = Math.min(end, endIndex)\n      total += (end - start + 1) * (isNaN(size) ? 0 : size)\n    }\n\n    return total\n  }\n\n  public getOffsets(indices: number[]): IndexList {\n    let tree = AATree.empty<number>()\n    indices.forEach(index => {\n      const offset = this.offsetOf(index)\n      tree = tree.insert(offset, index)\n    })\n    return new IndexList(tree)\n  }\n\n  public setInitialIndex(topMostItemIndex: number): OffsetList {\n    return new OffsetList(this.rangeTree, this.offsetTree, this.nanIndices, topMostItemIndex)\n  }\n\n  public getDefaultSize(): number {\n    return this.rangeTree.findMaxValue(Infinity)\n  }\n\n  public adjustForPrependedItems(count: number) {\n    return this.fromTree(this.rangeTree.shift(count))\n  }\n\n  public configureMaxRangeSize(maxRangeSize: number, maxRangeSizeExceededCallback: () => void) {\n    this.maxRangeSize = maxRangeSize\n    this.rangeSizeExceededCallback = maxRangeSizeExceededCallback\n  }\n}\n\nexport class IndexList {\n  public tree: AATree<number>\n  public constructor(tree: AATree<number>) {\n    this.tree = tree\n  }\n\n  public findMaxValue(offset: number): number {\n    return this.tree.findMaxValue(offset)\n  }\n\n  public empty(): boolean {\n    return this.tree.empty()\n  }\n}\n","import {\n  TObservable,\n  subject,\n  filter,\n  mapTo,\n  throttleTime,\n  scan,\n  map,\n  withLatestFrom,\n  duc,\n  combineLatest,\n} from '../tinyrx'\nimport { ComponentType } from 'react'\n\nexport interface ListRange {\n  startIndex: number\n  endIndex: number\n}\n\nexport interface ScrollSeekToggle {\n  (velocity: number, range: ListRange): boolean\n}\n\nexport type TSeekPlaceholder = ComponentType<{ height: number; index: number }>\n\nexport interface ScrollSeekConfiguration {\n  enter: ScrollSeekToggle\n  change: (velocity: number, range: ListRange) => void\n  exit: ScrollSeekToggle\n  placeholder: TSeekPlaceholder\n}\n\ninterface ScrollSeekParams {\n  isScrolling$: TObservable<boolean>\n  scrollTop$: TObservable<number>\n  rangeChanged$: TObservable<ListRange>\n}\n\nexport function scrollSeekEngine({ isScrolling$, scrollTop$, rangeChanged$: range$ }: ScrollSeekParams) {\n  const scrollVelocity$ = subject(0)\n  const isSeeking$ = subject(false)\n  const scrollSeekConfiguration$ = subject<ScrollSeekConfiguration | undefined | false>(false)\n\n  isScrolling$\n    .pipe(\n      filter(val => !val),\n      mapTo(0)\n    )\n    .subscribe(scrollVelocity$.next)\n\n  scrollTop$\n    .pipe(\n      throttleTime(100),\n      scan(([_, prev], next) => [prev, next], [0, 0]),\n      map(([prev, next]) => next - prev)\n    )\n    .subscribe(scrollVelocity$.next)\n\n  scrollVelocity$\n    .pipe(\n      withLatestFrom(scrollSeekConfiguration$, isSeeking$, range$),\n      filter(([_, config]) => !!config),\n      map(([speed, config, isSeeking, range]: any) => {\n        const { exit, enter } = config!\n        if (isSeeking) {\n          if (exit(speed, range)) {\n            return false\n          }\n        } else {\n          if (enter(speed, range)) {\n            return true\n          }\n        }\n        return isSeeking\n      }),\n      duc()\n    )\n    .subscribe(isSeeking$.next)\n\n  combineLatest(isSeeking$, scrollVelocity$, range$)\n    .pipe(withLatestFrom(scrollSeekConfiguration$))\n    .subscribe(([[isSeeking, velocity, range], config]) => isSeeking && config && config!.change(velocity, range))\n\n  return { isSeeking$, scrollSeekConfiguration$, scrollVelocity$ }\n}\n","import { TObservable, TSubscription } from './tinyrx'\n\nexport interface TOutput<T> {\n  (callback: TCallback<T> | undefined): void\n}\n\nexport interface TInput<T> {\n  (val: T): void\n}\n\ntype TCallback<T> = (val: T) => void\n\nexport function makeOutput<T>(observable: TObservable<T>): TOutput<T> {\n  let unsubscribe: TSubscription | undefined\n\n  return (callback: TCallback<T> | undefined) => {\n    if (unsubscribe) {\n      unsubscribe()\n    }\n    if (callback) {\n      unsubscribe = observable.subscribe(callback)\n    }\n  }\n}\n\nexport function makeInput<T>(subject: { next: (value: T) => void }): TInput<T> {\n  return subject.next\n}\n","import * as React from 'react'\nimport { ReactElement } from 'react'\nimport { coldSubject, combineLatest, duc, filter, map, subject, withLatestFrom } from '../src/tinyrx'\nimport { buildIsScrolling } from './EngineCommons'\nimport { adjustForPrependedItemsEngine } from './engines/adjustForPrependedItemsEngine'\nimport { followOutputEngine } from './engines/followOutputEngine'\nimport { groupCountEngine } from './engines/groupCountEgine'\nimport { listEngine } from './engines/listEngine'\nimport { maxRangeSizeEngine } from './engines/maxRangeSizeEngine'\nimport { offsetListEngine } from './engines/offsetListEngine'\nimport { scrolledToBottomEngine } from './engines/scrolledToBottomEngine'\nimport { ListRange, scrollSeekEngine } from './engines/scrollSeekEngine'\nimport { scrollToIndexEngine } from './engines/scrollToIndexEngine'\nimport { topItemCountEngine } from './engines/topItemCountEngine'\nimport { topListEngine } from './engines/topListEngine'\nimport { ListItem, StubIndexTransposer, Transposer } from './GroupIndexTransposer'\nimport { makeInput, makeOutput } from './rxio'\n\nexport interface ItemHeight {\n  start: number\n  end: number\n  size: number\n}\n\ninterface TVirtuosoConstructorParams {\n  overscan?: number\n  totalCount?: number\n  topItems?: number\n  itemHeight?: number\n  defaultItemHeight?: number\n  initialTopMostItemIndex?: number\n}\n\nconst VirtuosoStore = ({\n  overscan = 0,\n  totalCount = 0,\n  itemHeight,\n  initialTopMostItemIndex,\n  defaultItemHeight,\n}: TVirtuosoConstructorParams) => {\n  const transposer$ = subject<Transposer>(new StubIndexTransposer())\n  const viewportHeight$ = subject(0)\n  const scrollTop$ = subject(0, false)\n  const isScrolling$ = buildIsScrolling(scrollTop$)\n\n  const { topList$, minListIndex$, topListHeight$ } = topListEngine()\n  const {\n    stickyItems$,\n    initialItemCount$,\n    itemHeights$,\n    offsetList$,\n    totalCount$,\n    headerHeight$,\n    footerHeight$,\n    totalHeight$,\n    heightsChanged$,\n  } = offsetListEngine({\n    totalCount,\n    itemHeight,\n    defaultItemHeight,\n    initialTopMostItemIndex,\n    viewportHeight$,\n    scrollTop$,\n    transposer$,\n    topList$,\n  })\n\n  const { groupCounts$, groupIndices$ } = groupCountEngine({ totalCount$, transposer$, stickyItems$ })\n\n  const { scrolledToBottom$ } = scrolledToBottomEngine({ totalHeight$, viewportHeight$, scrollTop$ })\n\n  const { scrolledToTopMostItem$, scrollToIndex$, scrollTo$ } = scrollToIndexEngine({\n    initialTopMostItemIndex,\n    scrollTop$,\n    offsetList$,\n    viewportHeight$,\n    totalHeight$,\n    stickyItems$,\n    totalCount$,\n    topListHeight$,\n    heightsChanged$,\n  })\n\n  const { listHeight$, list$, listOffset$, startReached$, endReached$ } = listEngine({\n    overscan,\n    defaultItemHeight,\n    viewportHeight$,\n    scrollTop$,\n    totalHeight$,\n    topListHeight$,\n    headerHeight$,\n    footerHeight$,\n    minListIndex$,\n    totalCount$,\n    offsetList$,\n    scrolledToTopMostItem$,\n    transposer$,\n  })\n\n  const { adjustForPrependedItems$, adjustmentInProgress$ } = adjustForPrependedItemsEngine({\n    offsetList$,\n    scrollTop$,\n    scrollTo$,\n  })\n\n  const { maxRangeSize$ } = maxRangeSizeEngine({ scrollTo$, offsetList$, scrollTop$, list$ })\n\n  const { topItemCount$ } = topItemCountEngine({ offsetList$, totalCount$, transposer$, viewportHeight$, topList$ })\n\n  const { followOutput$ } = followOutputEngine({ totalCount$, scrollToIndex$, scrolledToBottom$ })\n\n  const stickyItemsOffset$ = listOffset$.pipe(map(offset => -offset))\n\n  const rangeChanged$ = coldSubject<ListRange>()\n\n  list$\n    .pipe(\n      withLatestFrom(adjustmentInProgress$),\n      filter<[ListItem[], boolean]>(([list, inProgress]) => list.length !== 0 && !inProgress),\n      map(([list]) => {\n        const { index: startIndex } = list[0]\n        const { index: endIndex } = list[list.length - 1]\n        return { startIndex, endIndex }\n      }),\n      duc((current, next) => !current || current.startIndex !== next.startIndex || current.endIndex !== next.endIndex)\n    )\n    .subscribe(rangeChanged$.next)\n\n  const { isSeeking$, scrollVelocity$, scrollSeekConfiguration$ } = scrollSeekEngine({\n    scrollTop$,\n    isScrolling$,\n    rangeChanged$,\n  })\n\n  const MAX_OFFSET_HEIGHT = 15000000\n  const domTotalHeight$ = totalHeight$.pipe(map(value => Math.min(value, MAX_OFFSET_HEIGHT)))\n\n  const scrollTopMultiplier$ = combineLatest(totalHeight$, domTotalHeight$, viewportHeight$).pipe(\n    map(([totalHeight, domTotalHeight, viewportHeight]) => {\n      if (totalHeight === domTotalHeight || domTotalHeight === viewportHeight) {\n        return 1\n      }\n      return (totalHeight - viewportHeight) / (domTotalHeight - viewportHeight)\n    })\n  )\n\n  const domScrollTop$ = subject(0, false)\n\n  const domListOffset$ = combineLatest(listOffset$, scrollTopMultiplier$).pipe(\n    map(([offset, multiplier]) => offset / multiplier)\n  )\n\n  combineLatest(domScrollTop$, scrollTopMultiplier$)\n    .pipe(map(([domScrollTop, multiplier]) => domScrollTop * multiplier))\n    .subscribe(scrollTop$.next)\n\n  const computeItemKey$ = subject((itemIndex: number) => itemIndex as React.Key)\n  const renderProp$ = subject((index: number, _groupIndex?: number) => index as any)\n  const groupRenderProp$ = subject((index: number) => index as any)\n  const itemContainer$ = subject<React.ComponentType<any> | string>('div')\n  const groupContainer$ = subject<React.ComponentType<any> | string>('div')\n  const itemRender$ = subject<any>(false)\n  const dataKey$ = subject<string | symbol | undefined>(Symbol('data-key'))\n\n  combineLatest(\n    renderProp$,\n    groupRenderProp$,\n    scrollSeekConfiguration$,\n    computeItemKey$,\n    itemContainer$,\n    groupContainer$,\n    dataKey$\n  )\n    .pipe(\n      map(([render, groupRender, scrollSeek, computeItemKey, ItemContainer, GroupContainer, _dataKey]) => {\n        return {\n          render: (item: any, { key, renderPlaceholder, ...itemProps }: any) => {\n            if (computeItemKey) {\n              key = computeItemKey(item.index)\n            }\n\n            if (item.type === 'group') {\n              return React.createElement(GroupContainer, { key, ...itemProps }, groupRender(item.groupIndex))\n            } else {\n              let children: ReactElement\n              if (scrollSeek && renderPlaceholder) {\n                children = React.createElement(scrollSeek.placeholder, {\n                  height: itemProps['data-known-size'],\n                  index: item.index,\n                })\n              } else {\n                children = render(item.transposedIndex, item.groupIndex)\n              }\n\n              return React.createElement(ItemContainer, { ...itemProps, key }, children)\n            }\n          },\n        }\n      })\n    )\n    .subscribe(itemRender$.next)\n\n  return {\n    groupCounts: makeInput(groupCounts$),\n    itemHeights: makeInput(itemHeights$),\n    headerHeight: makeInput(headerHeight$),\n    footerHeight: makeInput(footerHeight$),\n    listHeight: makeInput(listHeight$),\n    viewportHeight: makeInput(viewportHeight$),\n    scrollTop: makeInput(domScrollTop$),\n    topItemCount: makeInput(topItemCount$),\n    totalCount: makeInput(totalCount$),\n    scrollToIndex: makeInput(scrollToIndex$),\n    initialItemCount: makeInput(initialItemCount$),\n    followOutput: makeInput(followOutput$),\n    adjustForPrependedItems: makeInput(adjustForPrependedItems$),\n    maxRangeSize: makeInput(maxRangeSize$),\n    scrollSeekConfiguration: makeInput(scrollSeekConfiguration$),\n\n    renderProp: makeInput(renderProp$),\n    groupRenderProp: makeInput(groupRenderProp$),\n    computeItemKey: makeInput(computeItemKey$),\n    itemContainer: makeInput(itemContainer$),\n    groupContainer: makeInput(groupContainer$),\n    dataKey: makeInput(dataKey$),\n\n    itemRender: makeOutput(itemRender$),\n\n    list: makeOutput(list$),\n    isSeeking: makeOutput(isSeeking$),\n    scrollVelocity: makeOutput(scrollVelocity$),\n    itemsRendered: makeOutput(list$),\n    topList: makeOutput(topList$),\n    listOffset: makeOutput(domListOffset$),\n    totalHeight: makeOutput(domTotalHeight$),\n    startReached: makeOutput(startReached$),\n    endReached: makeOutput(endReached$),\n    atBottomStateChange: makeOutput(scrolledToBottom$),\n    totalListHeightChanged: makeOutput(totalHeight$),\n    rangeChanged: makeOutput(rangeChanged$),\n    isScrolling: makeOutput(isScrolling$),\n    stickyItems: makeOutput(stickyItems$),\n    groupIndices: makeOutput(groupIndices$),\n    stickyItemsOffset: makeOutput(stickyItemsOffset$),\n    scrollTo: makeOutput(scrollTo$),\n  }\n}\n\nexport { VirtuosoStore }\n","import { subject, map } from '../tinyrx'\nimport { ListItem } from '../GroupIndexTransposer'\n\nexport function topListEngine() {\n  const topList$ = subject<ListItem[]>([])\n\n  const topListHeight$ = topList$.pipe(map(items => items.reduce((total, item) => total + item.size, 0)))\n\n  const minListIndex$ = topList$.pipe(\n    map(topList => {\n      return topList.length && topList[topList.length - 1].index + 1\n    })\n  )\n\n  return {\n    topList$,\n    topListHeight$,\n    minListIndex$,\n  }\n}\n","import { OffsetList } from '../OffsetList'\nimport { combineLatest, map, subject, TSubject, withLatestFrom, coldSubject } from '../tinyrx'\nimport { ItemHeight } from '../VirtuosoStore'\nimport { initialItemCountEngine } from './initialItemCountEngine'\nimport { Transposer, ListItem } from '../GroupIndexTransposer'\nimport { stickyItemsEngine } from './stickyItemsEngine'\n\ninterface OffsetListEngineParams {\n  itemHeight: number | undefined\n  defaultItemHeight: number | undefined\n  initialTopMostItemIndex: number | undefined\n  totalCount: number\n  viewportHeight$: TSubject<number>\n  scrollTop$: TSubject<number>\n  topList$: TSubject<ListItem[]>\n  transposer$: TSubject<Transposer>\n}\n\nexport function offsetListEngine({\n  totalCount,\n  itemHeight,\n  defaultItemHeight,\n  initialTopMostItemIndex,\n  viewportHeight$,\n  scrollTop$,\n  topList$,\n  transposer$,\n}: OffsetListEngineParams) {\n  const headerHeight$ = subject(0)\n  const footerHeight$ = subject(0)\n  const totalCount$ = subject(totalCount)\n  const itemHeights$ = subject<ItemHeight[]>()\n  const { pendingRenderAfterInitial$, initialItemCount$ } = initialItemCountEngine({ itemHeights$, viewportHeight$ })\n  const heightsChanged$ = coldSubject<[boolean, OffsetList]>()\n\n  let initialOffsetList = OffsetList.create()\n\n  if (itemHeight) {\n    initialOffsetList = initialOffsetList.insert(0, 0, itemHeight)\n  }\n\n  if (defaultItemHeight) {\n    initialOffsetList = initialOffsetList.insert(0, 0, defaultItemHeight)\n  }\n\n  if (initialTopMostItemIndex) {\n    initialOffsetList = initialOffsetList.setInitialIndex(initialTopMostItemIndex)\n  }\n\n  const offsetList$ = subject(initialOffsetList)\n  const { stickyItems$ } = stickyItemsEngine({ offsetList$, scrollTop$, topList$, transposer$ })\n\n  const totalHeight$ = combineLatest(offsetList$, totalCount$, headerHeight$, footerHeight$).pipe(\n    map(\n      ([offsetList, totalCount, headerHeight, footerHeight]) =>\n        offsetList.total(totalCount - 1) + headerHeight + footerHeight\n    )\n  )\n\n  if (!itemHeight) {\n    itemHeights$\n      .pipe(withLatestFrom(offsetList$, stickyItems$, pendingRenderAfterInitial$))\n      .subscribe(([heights, offsetList, stickyItems, pendingRenderAfterInitial]) => {\n        let newList = offsetList\n\n        if (pendingRenderAfterInitial) {\n          newList = OffsetList.create()\n          pendingRenderAfterInitial = false\n        }\n\n        for (const { start, end, size } of heights) {\n          if (newList.empty() && start === end && stickyItems.indexOf(start) > -1) {\n            newList = newList.insertSpots(stickyItems, size)\n          } else {\n            newList = newList.insert(start, end, size)\n          }\n        }\n\n        if (newList !== offsetList) {\n          offsetList$.next(newList)\n          heightsChanged$.next([true, newList])\n        } else {\n          heightsChanged$.next([false, newList])\n        }\n      })\n  }\n\n  return {\n    totalCount$,\n    offsetList$,\n    totalHeight$,\n    headerHeight$,\n    footerHeight$,\n    initialItemCount$,\n    itemHeights$,\n    stickyItems$,\n    heightsChanged$,\n  }\n}\n","import { subject, TSubject } from '../tinyrx'\nimport { ItemHeight } from '../VirtuosoStore'\n\ninterface InitialItemCountEngineParams {\n  itemHeights$: TSubject<ItemHeight[]>\n  viewportHeight$: TSubject<number>\n}\nexport function initialItemCountEngine({ itemHeights$, viewportHeight$ }: InitialItemCountEngineParams) {\n  const initialItemCount$ = subject<number>()\n  const pendingRenderAfterInitial$ = subject(false)\n\n  const unsubscribeInitial = initialItemCount$.subscribe(count => {\n    const dummyItemHeight = 30\n    itemHeights$.next([{ start: 0, end: 0, size: dummyItemHeight }])\n    viewportHeight$.next(dummyItemHeight * count)\n    pendingRenderAfterInitial$.next(true)\n    unsubscribeInitial()\n  })\n\n  return { initialItemCount$, pendingRenderAfterInitial$ }\n}\n","import { subject, map, TObservable, combineLatest, filter, withLatestFrom, TSubject } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { Transposer, ListItem } from '../GroupIndexTransposer'\n\ninterface StickyItemsEngineParams {\n  offsetList$: TObservable<OffsetList>\n  scrollTop$: TObservable<number>\n  topList$: TSubject<ListItem[]>\n  transposer$: TObservable<Transposer>\n}\nexport function stickyItemsEngine({ offsetList$, scrollTop$, topList$, transposer$ }: StickyItemsEngineParams) {\n  const stickyItems$ = subject<number[]>([])\n\n  const stickyItemsIndexList$ = combineLatest(offsetList$, stickyItems$).pipe(\n    map(([offsetList, stickyItems]) => {\n      return offsetList.getOffsets(stickyItems)\n    })\n  )\n\n  combineLatest(offsetList$, stickyItemsIndexList$, scrollTop$)\n    .pipe(\n      filter(params => !params[1].empty() && !params[0].empty()),\n      withLatestFrom(topList$, transposer$),\n      map(([[offsetList, stickyItemsIndexList, scrollTop], topList, transposer]) => {\n        const currentStickyItem = stickyItemsIndexList.findMaxValue(Math.max(scrollTop, 0))\n\n        if (topList.length === 1 && topList[0].index === currentStickyItem) {\n          return topList\n        }\n\n        const item = offsetList.itemAt(currentStickyItem)\n        return transposer.transpose([item])\n      })\n    )\n    .subscribe(topList$.next)\n\n  return {\n    stickyItems$,\n  }\n}\n","import { GroupIndexTransposer, Transposer } from '../GroupIndexTransposer'\nimport { TSubject, subject } from '../tinyrx'\n\ninterface GroupCountParams {\n  totalCount$: TSubject<number>\n  stickyItems$: TSubject<number[]>\n  transposer$: TSubject<Transposer>\n}\nexport function groupCountEngine({ transposer$, stickyItems$, totalCount$ }: GroupCountParams) {\n  const groupCounts$ = subject<number[]>()\n  const groupIndices$ = stickyItems$.pipe()\n\n  groupCounts$.subscribe(counts => {\n    const transposer = new GroupIndexTransposer(counts)\n    transposer$.next(transposer)\n    totalCount$.next(transposer.totalCount())\n    stickyItems$.next(transposer.groupIndices())\n  })\n\n  return {\n    groupCounts$,\n    groupIndices$,\n  }\n}\n","import { TObservable, subject, combineLatest, map } from '../tinyrx'\n\ninterface ScrolledToBottomParams {\n  scrollTop$: TObservable<number>\n  viewportHeight$: TObservable<number>\n  totalHeight$: TObservable<number>\n}\n\nexport function scrolledToBottomEngine({ totalHeight$, viewportHeight$, scrollTop$ }: ScrolledToBottomParams) {\n  const scrolledToBottom$ = subject(false)\n\n  let notAtBottom: number\n\n  combineLatest(scrollTop$, viewportHeight$, totalHeight$)\n    .pipe(\n      map(([scrollTop, viewportHeight, totalHeight]) => {\n        if (viewportHeight === 0) return false\n        return totalHeight - viewportHeight - scrollTop <= 1 || totalHeight <= viewportHeight\n      })\n    )\n    .subscribe(value => {\n      clearTimeout(notAtBottom)\n      if (!value) {\n        notAtBottom = setTimeout(() => scrolledToBottom$.next(false))\n      } else {\n        scrolledToBottom$.next(true)\n      }\n    })\n\n  return {\n    scrolledToBottom$,\n  }\n}\n","import { TScrollLocation } from '../EngineCommons'\nimport { OffsetList } from '../OffsetList'\nimport { coldSubject, map, subject, TObservable, TSubject, withLatestFrom, filter } from '../tinyrx'\nimport { initialTopMostItemIndexEngine } from './initialTopMostItemEngine'\n\nexport interface ScrollToIndexParams {\n  heightsChanged$: TSubject<[boolean, OffsetList]>\n  offsetList$: TSubject<OffsetList>\n  topListHeight$: TObservable<number>\n  stickyItems$: TObservable<number[]>\n  viewportHeight$: TSubject<number>\n  totalCount$: TObservable<number>\n  totalHeight$: TObservable<number>\n  scrollTop$: TObservable<number>\n  initialTopMostItemIndex: number | undefined\n}\n\nexport function scrollToIndexEngine({\n  offsetList$,\n  topListHeight$,\n  stickyItems$,\n  viewportHeight$,\n  totalCount$,\n  totalHeight$,\n  initialTopMostItemIndex,\n  heightsChanged$,\n  scrollTop$,\n}: ScrollToIndexParams) {\n  const scrollToIndex$ = coldSubject<TScrollLocation>()\n  const scrollToIndexRequestPending$ = subject(false)\n  const scrollTopReportedAfterScrollToIndex$ = subject(true)\n  const scrollTo$ = coldSubject<ScrollToOptions>()\n\n  const { scrolledToTopMostItem$ } = initialTopMostItemIndexEngine({\n    scrollTo$,\n    offsetList$,\n    scrollToIndex$,\n    scrollTop$,\n    initialTopMostItemIndex,\n  })\n\n  heightsChanged$.pipe(withLatestFrom(scrolledToTopMostItem$)).subscribe(([[changed], scrolledToTopMostItem]) => {\n    if (!changed && scrolledToTopMostItem) {\n      scrollToIndexRequestPending$.next(false)\n      scrollTopReportedAfterScrollToIndex$.next(true)\n    }\n  })\n\n  scrollToIndex$\n    .pipe(\n      withLatestFrom(offsetList$, topListHeight$, stickyItems$, viewportHeight$, totalCount$, totalHeight$),\n      map(([location, offsetList, topListHeight, stickyItems, viewportHeight, totalCount, totalHeight]) => {\n        if (offsetList.empty()) {\n          setTimeout(() => scrollToIndex$.next(location))\n          return\n        }\n\n        if (typeof location === 'number') {\n          location = { index: location, align: 'start', behavior: 'auto' }\n        }\n        let { index, align = 'start' } = location\n\n        index = Math.max(0, index, Math.min(totalCount - 1, index))\n\n        let offset = offsetList.offsetOf(index)\n        if (align === 'end') {\n          offset = offset - viewportHeight + offsetList.itemAt(index).size\n        } else if (align === 'center') {\n          offset = Math.round(offset - viewportHeight / 2 + offsetList.itemAt(index).size / 2)\n        } else {\n          if (stickyItems.indexOf(index) === -1) {\n            offset -= topListHeight\n          }\n        }\n\n        scrollTopReportedAfterScrollToIndex$.next(false)\n        return {\n          top: Math.max(0, Math.min(offset, Math.floor(totalHeight - viewportHeight))),\n          behavior: location.behavior ?? 'auto',\n        }\n      }),\n      filter(value => value !== undefined)\n    )\n    .subscribe(scrollTo$.next as any)\n\n  scrollTop$.pipe(withLatestFrom(scrollTopReportedAfterScrollToIndex$)).subscribe(([_, scrollTopReported]) => {\n    if (!scrollTopReported) {\n      scrollTopReportedAfterScrollToIndex$.next(true)\n      scrollToIndexRequestPending$.next(true)\n    }\n  })\n\n  // if the list has received new heights, the scrollTo call calculations were wrong;\n  // we will retry by re-requesting the same index\n  offsetList$\n    .pipe(withLatestFrom(scrollToIndexRequestPending$, scrollToIndex$))\n    .subscribe(([_, scrollToIndexRequestPending, scrollToIndex]) => {\n      if (scrollToIndexRequestPending) {\n        scrollToIndex$.next(scrollToIndex)\n      }\n    })\n\n  return {\n    scrollToIndex$,\n    scrollTo$,\n    scrolledToTopMostItem$,\n  }\n}\n","import { subject, TObservable, TSubject, withLatestFrom } from '../tinyrx'\nimport { TScrollLocation } from '../EngineCommons'\nimport { OffsetList } from '../OffsetList'\n\nexport interface InitialTopMostItemIndexParams {\n  initialTopMostItemIndex: number | undefined\n  scrollTop$: TObservable<number>\n  scrollTo$: TSubject<ScrollToOptions>\n  scrollToIndex$: TSubject<TScrollLocation>\n  offsetList$: TObservable<OffsetList>\n}\n\nexport function initialTopMostItemIndexEngine({\n  initialTopMostItemIndex,\n  scrollToIndex$,\n  scrollTop$,\n  scrollTo$,\n  offsetList$,\n}: InitialTopMostItemIndexParams) {\n  const scrolledToTopMostItem$ = subject(!initialTopMostItemIndex)\n\n  scrollTop$\n    .pipe(withLatestFrom(scrollTo$, scrolledToTopMostItem$))\n    .subscribe(([scrollTop, scrollTo, scrolledToTopMostItem]) => {\n      if (scrollTop === scrollTo.top && !scrolledToTopMostItem) {\n        // skip a tick, so that the list$ can grab the scrollTop$ update\n        setTimeout(() => {\n          scrolledToTopMostItem$.next(true)\n        })\n      }\n    })\n\n  offsetList$.pipe(withLatestFrom(scrolledToTopMostItem$)).subscribe(([_, scrolledToTopMostItem]) => {\n    if (!scrolledToTopMostItem) {\n      // hack: wait for the viewport to get populated :(\n      setTimeout(() => {\n        scrollToIndex$.next(initialTopMostItemIndex!)\n      })\n    }\n  })\n\n  return {\n    scrolledToTopMostItem$,\n  }\n}\n","import { TObservable, withLatestFrom, coldSubject, TSubject, subject } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\n\ninterface AdjustForPrependedItemsParams {\n  offsetList$: TSubject<OffsetList>\n  scrollTop$: TObservable<number>\n  scrollTo$: TSubject<ScrollToOptions>\n}\n\nexport function adjustForPrependedItemsEngine({ offsetList$, scrollTop$, scrollTo$ }: AdjustForPrependedItemsParams) {\n  const adjustForPrependedItems$ = coldSubject<number>()\n\n  const adjustmentInProgress$ = subject(false)\n  adjustForPrependedItems$\n    .pipe(withLatestFrom(offsetList$, scrollTop$, adjustmentInProgress$))\n    .subscribe(([count, offsetList, scrollTop, inProgress]) => {\n      if (inProgress || offsetList.empty()) {\n        return\n      }\n\n      adjustmentInProgress$.next(true)\n      offsetList$.next(offsetList.adjustForPrependedItems(count))\n\n      setTimeout(() => {\n        scrollTo$.next({ top: count * offsetList.getDefaultSize() + scrollTop })\n        adjustmentInProgress$.next(false)\n      })\n    })\n\n  return { adjustForPrependedItems$, adjustmentInProgress$ }\n}\n","import { TObservable, TSubject, subject, withLatestFrom } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { ListItem } from '../GroupIndexTransposer'\n\nexport interface MaxRangeSizeParams {\n  offsetList$: TSubject<OffsetList>\n  scrollTo$: TSubject<ScrollToOptions>\n  scrollTop$: TObservable<number>\n  list$: TObservable<ListItem[]>\n}\n\nexport function maxRangeSizeEngine({ list$, offsetList$, scrollTop$, scrollTo$ }: MaxRangeSizeParams) {\n  const scheduledReadjust$ = subject<{ index: number; offset: number } | null>(null)\n  const maxRangeSize$ = subject(Infinity)\n\n  //////////////\n  // Max range size implementation\n  // the scheduledReadjust$ can be removed through the trapNext pattern\n  //////////////\n\n  // 1. List warns us that it will reset itself.\n  offsetList$\n    .pipe(withLatestFrom(maxRangeSize$, scrollTop$, list$))\n    .subscribe(([offsetList, maxRangeSize, scrollTop, list]) =>\n      offsetList.configureMaxRangeSize(maxRangeSize, () => {\n        // 2. we pick the adjustment signal and capture the list state *before* it gets reset\n        scheduledReadjust$.next({ index: list[0].index, offset: scrollTop - list[0].offset })\n      })\n    )\n\n  // 3. once the offset list is reset, we compensate the scroll.\n  offsetList$.pipe(withLatestFrom(scheduledReadjust$)).subscribe(([offsetList, adjust]) => {\n    if (adjust !== null) {\n      const scrollTo = offsetList.offsetOf(adjust!.index) + adjust!.offset\n      scrollTo$.next({ top: scrollTo })\n      scheduledReadjust$.next(null)\n    }\n  })\n  return {\n    maxRangeSize$,\n  }\n}\n","import { TObservable, subject, combineLatest, filter, withLatestFrom, map, TSubject } from '../tinyrx'\nimport { OffsetList } from '../OffsetList'\nimport { Transposer, ListItem } from '../GroupIndexTransposer'\n\ninterface TopItemCountParams {\n  offsetList$: TObservable<OffsetList>\n  totalCount$: TObservable<number>\n  topList$: TSubject<ListItem[]>\n  viewportHeight$: TObservable<number>\n  transposer$: TObservable<Transposer>\n}\nexport function topItemCountEngine({\n  topList$,\n  transposer$,\n  viewportHeight$,\n  totalCount$,\n  offsetList$,\n}: TopItemCountParams) {\n  const topItemCount$ = subject<number>()\n\n  combineLatest(offsetList$, topItemCount$, totalCount$, viewportHeight$)\n    .pipe(\n      filter(params => params[1] > 0 && params[3] > 0),\n      withLatestFrom(transposer$),\n      map(([[offsetList, topItemCount, totalCount], transposer]) => {\n        const endIndex = Math.max(0, Math.min(topItemCount - 1, totalCount))\n        return transposer.transpose(offsetList.indexRange(0, endIndex))\n      })\n    )\n    .subscribe(topList$.next)\n  return { topItemCount$ }\n}\n","import { TScrollLocation } from '../EngineCommons'\nimport { TObservable, TSubject, subject, combineLatest, withLatestFrom } from '../tinyrx'\n\ninterface FollowOutputParams {\n  totalCount$: TObservable<number>\n  scrolledToBottom$: TSubject<boolean>\n  scrollToIndex$: TSubject<TScrollLocation>\n}\nexport function followOutputEngine({ scrollToIndex$, scrolledToBottom$, totalCount$ }: FollowOutputParams) {\n  const followOutput$ = subject(false)\n\n  combineLatest(followOutput$, totalCount$)\n    .pipe(withLatestFrom(scrolledToBottom$))\n    .subscribe(([[followOutput, totalCount], scrolledToBottom]) => {\n      if (followOutput && scrolledToBottom) {\n        setTimeout(() => {\n          scrollToIndex$.next({ index: totalCount - 1, align: 'end', behavior: 'auto' })\n        })\n      }\n    })\n  return {\n    followOutput$,\n  }\n}\n","import { CSSProperties } from 'react'\n\nexport const viewportStyle: CSSProperties = {\n  top: 0,\n  position: 'absolute',\n  height: '100%',\n  width: '100%',\n}\n","import { useEffect, useRef, useState } from 'react'\nimport ResizeObserver from 'resize-observer-polyfill'\nimport { TInput, TOutput } from './rxio'\n\nexport type CallbackRefParam = HTMLElement | null\nexport type CallbackRef = (ref: CallbackRefParam) => void\n\ntype UseHeight = (\n  input: TInput<number>,\n  onMount?: (ref: CallbackRefParam) => void,\n  onResize?: (ref: HTMLElement) => void\n) => CallbackRef\n\nexport const useHeight: UseHeight = (input, onMount, onResize) => {\n  const ref = useRef<CallbackRefParam>(null)\n  const animationFrameID = useRef<number>(0)\n  const observer = new ResizeObserver(entries => {\n    const newHeight = Math.round(entries[0].contentRect.height)\n    if (onResize) {\n      animationFrameID.current = window.requestAnimationFrame(() => {\n        const element = entries[0].target as HTMLElement\n        if (document.body.contains(element)) {\n          onResize(element)\n        }\n      })\n    }\n    input(newHeight)\n  })\n\n  const callbackRef = (elRef: CallbackRefParam) => {\n    if (elRef) {\n      observer.observe(elRef)\n      if (onMount) {\n        onMount(elRef)\n      }\n      ref.current = elRef\n    } else {\n      observer.unobserve(ref.current!)\n      ref.current = null\n    }\n  }\n\n  useEffect(() => () => window.cancelAnimationFrame(animationFrameID.current), [])\n  return callbackRef\n}\n\nfunction callbackToValue<T>(output: (callback: (val: T) => void) => void, defaultValue: T) {\n  return () => {\n    let result = defaultValue\n    output(val => {\n      result = val\n    })\n    return result\n  }\n}\n\nexport function useOutput<T>(output: TOutput<T>, initialValue: T): T {\n  const [value, setValue] = useState(callbackToValue<T>(output, initialValue))\n\n  useEffect(() => {\n    output(setValue)\n    return () => output(undefined)\n  }, [output])\n  return value\n}\n\ntype UseSize = (callback: (params: { element: HTMLElement; width: number; height: number }) => void) => CallbackRef\n\nexport const useSize: UseSize = callback => {\n  const ref = useRef<CallbackRefParam>(null)\n  const currentSize = useRef([0, 0])\n\n  const observer = new ResizeObserver(entries => {\n    const { width, height } = entries[0].contentRect\n    if (currentSize.current[0] !== width || currentSize.current[1] !== height) {\n      currentSize.current = [width, height]\n      callback({\n        element: entries[0].target as HTMLElement,\n        width: Math.round(width),\n        height: Math.round(height),\n      })\n    }\n  })\n\n  const callbackRef = (elRef: CallbackRefParam) => {\n    if (elRef) {\n      observer.observe(elRef)\n      ref.current = elRef\n    } else {\n      observer.unobserve(ref.current!)\n      ref.current = null\n    }\n  }\n\n  return callbackRef\n}\n\nexport function simpleMemoize<T extends () => any>(func: T): T {\n  let called = false\n  let result: any\n\n  return (() => {\n    if (!called) {\n      called = true\n      result = func()\n    }\n    return result\n  }) as T\n}\n\nconst WEBKIT_STICKY = '-webkit-sticky'\nconst STICKY = 'sticky'\n\nexport const positionStickyCssValue = simpleMemoize(() => {\n  const node = document.createElement('div')\n  node.style.position = WEBKIT_STICKY\n  return node.style.position === WEBKIT_STICKY ? WEBKIT_STICKY : STICKY\n})\n","import * as React from 'react'\nimport { FC } from 'react'\n\nexport const VirtuosoFiller: FC<{ height: number }> = ({ height }) => (\n  <div style={{ height: `${height}px`, position: 'absolute', top: 0 }}>&nbsp;</div>\n)\n","import * as React from 'react'\nimport { useContext, ReactElement, CSSProperties, ReactNode, createElement, ComponentType } from 'react'\nimport { useOutput, positionStickyCssValue } from './Utils'\nimport { VirtuosoContext } from './VirtuosoContext'\nimport { ListItem } from './GroupIndexTransposer'\n\nexport interface TRenderProps {\n  key: React.Key\n  'data-index': number\n  'data-known-size': number\n  renderPlaceholder: boolean\n  style?: CSSProperties\n}\nexport type TRender = (item: ListItem, props: TRenderProps) => ReactElement\n\nexport interface VirtuosoListProps {\n  emptyComponent?: ComponentType\n}\n\nexport const VirtuosoList: React.FC<VirtuosoListProps> = React.memo(({ emptyComponent }) => {\n  const { isSeeking, topList, list, itemRender } = useContext(VirtuosoContext)!\n  const items = useOutput<ListItem[]>(list, [])\n  const topItems = useOutput<ListItem[]>(topList, [])\n  const render = useOutput(itemRender, false as any)\n  const renderPlaceholder = useOutput(isSeeking, false)\n\n  const renderedItems: ReactNode[] = []\n  let topOffset = 0\n  const renderedTopItemIndices: number[] = []\n\n  const marginTop = topItems.reduce((acc, item) => {\n    return acc + item.size\n  }, 0)\n\n  topItems.forEach((item, index) => {\n    const itemIndex = item.index\n    renderedTopItemIndices.push(itemIndex)\n\n    const style: CSSProperties = {\n      top: `${topOffset}px`,\n      marginTop: index === 0 ? `${-marginTop}px` : undefined,\n      zIndex: 2,\n      position: positionStickyCssValue(),\n    }\n\n    const props = {\n      key: itemIndex,\n      'data-index': itemIndex,\n      'data-known-size': item.size,\n      renderPlaceholder,\n      style,\n    }\n\n    render && renderedItems.push(render.render(item, props))\n    topOffset += item.size\n  })\n\n  items.forEach(item => {\n    if (renderedTopItemIndices.indexOf(item.index) > -1) {\n      return\n    }\n\n    render &&\n      renderedItems.push(\n        render.render(item, {\n          key: item.index,\n          'data-index': item.index,\n          'data-known-size': item.size,\n          renderPlaceholder,\n        })\n      )\n  })\n\n  if (renderedItems.length === 0 && emptyComponent) return createElement(emptyComponent)\n  return <>{renderedItems}</>\n})\n","import * as React from 'react'\nimport { FC, CSSProperties, useCallback, useRef } from 'react'\n\nconst scrollerStyle: React.CSSProperties = {\n  height: '100%',\n  overflowY: 'auto',\n  WebkitOverflowScrolling: 'touch',\n  position: 'relative',\n  outline: 'none',\n}\n\nexport type TScrollContainer = FC<{\n  style: CSSProperties\n  className?: string\n  reportScrollTop: (scrollTop: number) => void\n  scrollTo: (callback: (scrollTop: ScrollToOptions) => void) => void\n}>\n\nconst DefaultScrollContainer: TScrollContainer = ({ className, style, reportScrollTop, scrollTo, children }) => {\n  const elRef = useRef<HTMLElement | null>(null)\n  const smoothScrollTarget = useRef<number | null>(null)\n  const currentScrollTop = useRef<number | null>()\n\n  const onScroll: EventListener = useCallback(\n    (e: Event) => {\n      const scrollTop = (e.target as HTMLDivElement).scrollTop\n      currentScrollTop.current = scrollTop\n      if (smoothScrollTarget.current !== null) {\n        if (smoothScrollTarget.current === scrollTop) {\n          // console.log('reporting smooth scrolling')\n          smoothScrollTarget.current = null\n          reportScrollTop(scrollTop)\n        } else {\n          // console.log('skip reporting')\n        }\n      } else {\n        reportScrollTop(scrollTop)\n      }\n    },\n    [reportScrollTop]\n  )\n\n  const ref = useCallback(\n    (theRef: HTMLElement | null) => {\n      if (theRef) {\n        theRef.addEventListener('scroll', onScroll, { passive: true })\n        elRef.current = theRef\n      } else {\n        if (elRef.current) {\n          elRef.current.removeEventListener('scroll', onScroll)\n        }\n      }\n    },\n    [onScroll]\n  )\n\n  scrollTo(location => {\n    if (currentScrollTop.current !== location.top) {\n      if (location.behavior === 'smooth') {\n        smoothScrollTarget.current = location.top!\n      }\n      elRef.current && elRef.current!.scrollTo(location)\n    }\n  })\n\n  return (\n    <div ref={ref} style={style} tabIndex={0} className={className}>\n      {children}\n    </div>\n  )\n}\n\nexport const VirtuosoScroller: FC<{\n  className?: string\n  style: CSSProperties\n  ScrollContainer?: TScrollContainer\n  scrollTop: (scrollTop: number) => void\n  scrollTo: (callback: (scrollTop: ScrollToOptions) => void) => void\n}> = ({ children, style, className, ScrollContainer = DefaultScrollContainer, scrollTop, scrollTo }) => {\n  return (\n    <ScrollContainer\n      style={{ ...scrollerStyle, ...style }}\n      reportScrollTop={scrollTop}\n      scrollTo={scrollTo}\n      className={className}\n    >\n      {children}\n    </ScrollContainer>\n  )\n}\n","import * as React from 'react'\nimport { CSSProperties, FC, ReactElement, useContext, ComponentType } from 'react'\nimport { ItemHeight } from 'VirtuosoStore'\nimport { viewportStyle } from './Style'\nimport { CallbackRef, useHeight, useOutput } from './Utils'\nimport { VirtuosoContext } from './VirtuosoContext'\nimport { VirtuosoFiller } from './VirtuosoFiller'\nimport { VirtuosoList } from './VirtuosoList'\nimport { TScrollContainer, VirtuosoScroller } from './VirtuosoScroller'\n\nexport const DefaultHeaderContainer: React.FC<{ headerRef: CallbackRef }> = ({ children, headerRef }) => (\n  <header ref={headerRef}>{children}</header>\n)\n\nexport const DefaultFooterContainer: React.FC<{ footerRef: CallbackRef }> = ({ children, footerRef }) => (\n  <footer ref={footerRef}>{children}</footer>\n)\n\nexport const DefaultListContainer: React.FC<{ listRef: CallbackRef; style: CSSProperties }> = ({\n  children,\n  listRef,\n  style,\n}) => {\n  return (\n    <div ref={listRef} style={style}>\n      {children}\n    </div>\n  )\n}\n\nexport type TListContainer = typeof DefaultListContainer\nexport type THeaderContainer = typeof DefaultHeaderContainer\nexport type TFooterContainer = typeof DefaultFooterContainer\n\nexport { TScrollContainer }\n\nconst VirtuosoHeader: FC<{ header: () => ReactElement; HeaderContainer?: THeaderContainer }> = ({\n  header,\n  HeaderContainer = DefaultHeaderContainer,\n}) => {\n  const headerCallbackRef = useHeight(useContext(VirtuosoContext)!.headerHeight)\n  return <HeaderContainer headerRef={headerCallbackRef}>{header()}</HeaderContainer>\n}\n\nconst VirtuosoFooter: FC<{ footer: () => ReactElement; FooterContainer?: TFooterContainer }> = ({\n  footer,\n  FooterContainer = DefaultFooterContainer,\n}) => {\n  const footerCallbackRef = useHeight(useContext(VirtuosoContext)!.footerHeight)\n  return <FooterContainer footerRef={footerCallbackRef}>{footer()}</FooterContainer>\n}\n\nconst getHeights = (children: HTMLCollection) => {\n  const results: ItemHeight[] = []\n  for (let i = 0, len = children.length; i < len; i++) {\n    const child = children.item(i) as HTMLElement\n\n    if (!child || child.dataset.index === undefined) {\n      continue\n    }\n\n    const index = parseInt(child.dataset.index!)\n    const knownSize = parseInt(child.dataset.knownSize!)\n    const size = child.offsetHeight\n\n    if (size === knownSize || size === 0) {\n      continue\n    }\n\n    const lastResult = results[results.length - 1]\n    if (results.length === 0 || lastResult.size !== size || lastResult.end !== index - 1) {\n      results.push({ start: index, end: index, size })\n    } else {\n      results[results.length - 1].end++\n    }\n  }\n\n  return results\n}\n\nconst ListWrapper: React.FC<{ fixedItemHeight: boolean; ListContainer: TListContainer }> = ({\n  fixedItemHeight,\n  children,\n  ListContainer,\n}) => {\n  const { listHeight, itemHeights, listOffset } = useContext(VirtuosoContext)!\n  const translate = useOutput<number>(listOffset, 0)\n  const style = { marginTop: `${translate}px` }\n\n  const listCallbackRef = useHeight(\n    listHeight,\n    () => {},\n    ref => {\n      if (!fixedItemHeight) {\n        const measuredItemHeights = getHeights(ref!.children)\n        itemHeights(measuredItemHeights)\n      }\n    }\n  )\n\n  return (\n    <ListContainer listRef={listCallbackRef} style={style}>\n      {children}\n    </ListContainer>\n  )\n}\n\nexport const VirtuosoView: React.FC<{\n  style: CSSProperties\n  className?: string\n  header?: () => ReactElement\n  footer?: () => ReactElement\n  ScrollContainer?: TScrollContainer\n  ListContainer: TListContainer\n  HeaderContainer?: THeaderContainer\n  FooterContainer?: TFooterContainer\n  fixedItemHeight: boolean\n  emptyComponent?: ComponentType\n}> = ({\n  style,\n  header,\n  footer,\n  fixedItemHeight,\n  ScrollContainer,\n  ListContainer,\n  HeaderContainer,\n  FooterContainer,\n  className,\n  emptyComponent,\n}) => {\n  const { scrollTo, scrollTop, totalHeight, viewportHeight } = useContext(VirtuosoContext)!\n  const fillerHeight = useOutput<number>(totalHeight, 0)\n  const reportScrollTop = (st: number) => {\n    scrollTop(Math.max(st, 0))\n  }\n\n  const viewportCallbackRef = useHeight(viewportHeight)\n\n  return (\n    <VirtuosoScroller\n      style={style}\n      ScrollContainer={ScrollContainer}\n      className={className}\n      scrollTo={scrollTo}\n      scrollTop={reportScrollTop}\n    >\n      <div ref={viewportCallbackRef} style={viewportStyle}>\n        <ListWrapper fixedItemHeight={fixedItemHeight} ListContainer={ListContainer}>\n          {header && <VirtuosoHeader header={header} HeaderContainer={HeaderContainer} />}\n          <VirtuosoList emptyComponent={emptyComponent} />\n          {footer && <VirtuosoFooter footer={footer} FooterContainer={FooterContainer} />}\n        </ListWrapper>\n      </div>\n\n      <VirtuosoFiller height={fillerHeight} />\n    </VirtuosoScroller>\n  )\n}\n","import * as React from 'react'\nimport {\n  CSSProperties,\n  FC,\n  forwardRef,\n  ReactElement,\n  useImperativeHandle,\n  useEffect,\n  useState,\n  ComponentType,\n} from 'react'\nimport { TScrollLocation } from './EngineCommons'\nimport { ListRange, ScrollSeekConfiguration } from './engines/scrollSeekEngine'\nimport { ListItem } from './GroupIndexTransposer'\nimport { TSubscriber } from './tinyrx'\nimport { VirtuosoContext } from './VirtuosoContext'\nimport { TRenderProps } from './VirtuosoList'\nimport { VirtuosoStore } from './VirtuosoStore'\nimport {\n  DefaultListContainer,\n  THeaderContainer,\n  TFooterContainer,\n  TListContainer,\n  TScrollContainer,\n  VirtuosoView,\n} from './VirtuosoView'\n\nexport type VirtuosoState = ReturnType<typeof VirtuosoStore>\n\nexport type TItemContainer = React.FC<Omit<TRenderProps, 'renderPlaceholder' | 'scrollVelocity'>>\n\nexport interface VirtuosoProps {\n  totalCount: number\n  overscan?: number\n  topItems?: number\n  header?: () => ReactElement\n  footer?: () => ReactElement\n  item: (index: number) => ReactElement\n  computeItemKey?: (index: number) => React.Key\n  prependItemCount?: number\n  itemHeight?: number\n  defaultItemHeight?: number\n  startReached?: () => void\n  endReached?: (index: number) => void\n  scrollingStateChange?: TSubscriber<boolean>\n  atBottomStateChange?: TSubscriber<boolean>\n  itemsRendered?: TSubscriber<ListItem[]>\n  rangeChanged?: TSubscriber<ListRange>\n  totalListHeightChanged?: TSubscriber<number>\n  style?: CSSProperties\n  dataKey?: string\n  className?: string\n  initialItemCount?: number\n  initialTopMostItemIndex?: number\n  followOutput?: boolean\n  ScrollContainer?: TScrollContainer\n  HeaderContainer?: THeaderContainer\n  FooterContainer?: TFooterContainer\n  ListContainer?: TListContainer\n  ItemContainer?: TItemContainer\n  maxHeightCacheSize?: number\n  scrollSeek?: ScrollSeekConfiguration\n  emptyComponent?: ComponentType\n}\n\nexport interface TVirtuosoPresentationProps {\n  contextValue: VirtuosoState\n  header?: () => ReactElement\n  footer?: () => ReactElement\n  style?: CSSProperties\n  className?: string\n  itemHeight?: number\n  ScrollContainer?: TScrollContainer\n  HeaderContainer?: THeaderContainer\n  FooterContainer?: TFooterContainer\n  ListContainer?: TListContainer\n  emptyComponent?: ComponentType\n}\n\nexport { TScrollContainer, TListContainer }\n\nconst DEFAULT_STYLE = {}\nexport const VirtuosoPresentation: FC<TVirtuosoPresentationProps> = React.memo(\n  ({\n    contextValue,\n    style,\n    className,\n    header,\n    footer,\n    itemHeight,\n    ScrollContainer,\n    ListContainer,\n    HeaderContainer,\n    FooterContainer,\n    emptyComponent,\n  }) => {\n    return (\n      <VirtuosoContext.Provider value={contextValue}>\n        <VirtuosoView\n          style={style || DEFAULT_STYLE}\n          className={className}\n          header={header}\n          footer={footer}\n          fixedItemHeight={itemHeight !== undefined}\n          ScrollContainer={ScrollContainer}\n          HeaderContainer={HeaderContainer}\n          FooterContainer={FooterContainer}\n          ListContainer={ListContainer || DefaultListContainer}\n          emptyComponent={emptyComponent}\n        />\n      </VirtuosoContext.Provider>\n    )\n  }\n)\n\nexport interface VirtuosoMethods {\n  scrollToIndex(location: TScrollLocation): void\n  adjustForPrependedItems(count: number): void\n}\n\nexport const Virtuoso = forwardRef<VirtuosoMethods, VirtuosoProps>((props, ref) => {\n  const [state] = useState(() => VirtuosoStore(props))\n  useImperativeHandle(\n    ref,\n    () => ({\n      scrollToIndex: (location: TScrollLocation) => {\n        state.scrollToIndex(location)\n      },\n\n      adjustForPrependedItems: (count: number) => {\n        state.adjustForPrependedItems(count)\n      },\n    }),\n    [state]\n  )\n\n  useEffect(() => {\n    state.isScrolling(props.scrollingStateChange)\n    state.atBottomStateChange(props.atBottomStateChange)\n    state.startReached(props.startReached)\n    state.endReached(props.endReached)\n    state.topItemCount(props.topItems || 0)\n    state.totalCount(props.totalCount)\n    props.initialItemCount && state.initialItemCount(props.initialItemCount)\n    state.itemsRendered(props.itemsRendered)\n    state.totalListHeightChanged(props.totalListHeightChanged)\n    state.followOutput(!!props.followOutput)\n    state.maxRangeSize(props.maxHeightCacheSize || Infinity)\n    state.rangeChanged(props.rangeChanged)\n    state.scrollSeekConfiguration(props.scrollSeek)\n    state.computeItemKey(props.computeItemKey || (key => key))\n    state.itemContainer(props.ItemContainer || 'div')\n    state.renderProp(props.item)\n    state.dataKey(props.dataKey)\n\n    return () => {\n      state.itemsRendered(undefined)\n      state.totalListHeightChanged(undefined)\n    }\n  }, [\n    state,\n    props.scrollingStateChange,\n    props.atBottomStateChange,\n    props.startReached,\n    props.endReached,\n    props.topItems,\n    props.totalCount,\n    props.initialItemCount,\n    props.itemsRendered,\n    props.totalListHeightChanged,\n    props.followOutput,\n    props.maxHeightCacheSize,\n    props.rangeChanged,\n    props.scrollSeek,\n    props.item,\n    props.ItemContainer,\n    props.computeItemKey,\n    props.dataKey,\n  ])\n\n  return (\n    <VirtuosoPresentation\n      contextValue={state}\n      style={props.style}\n      className={props.className}\n      header={props.header}\n      footer={props.footer}\n      itemHeight={props.itemHeight}\n      ScrollContainer={props.ScrollContainer}\n      HeaderContainer={props.HeaderContainer}\n      FooterContainer={props.FooterContainer}\n      ListContainer={props.ListContainer}\n      emptyComponent={props.emptyComponent}\n    />\n  )\n})\n\nVirtuoso.displayName = 'Virtuoso'\n","import * as React from 'react'\nimport { forwardRef, ReactElement, useImperativeHandle, useState, useEffect } from 'react'\nimport { TScrollLocation } from './EngineCommons'\nimport { TItemContainer, VirtuosoPresentation, VirtuosoProps } from './Virtuoso'\nimport { VirtuosoStore } from './VirtuosoStore'\n\ntype GroupedVirtuosoProps = Pick<VirtuosoProps, Exclude<keyof VirtuosoProps, 'totalCount' | 'topItems' | 'item'>> & {\n  groupCounts: number[]\n  group: (groupIndex: number) => ReactElement\n  item: (index: number, groupIndex?: number) => ReactElement\n  groupIndices?: (indices: number[]) => void\n  GroupContainer?: TItemContainer\n}\n\nexport interface GroupedVirtuosoMethods {\n  scrollToIndex(location: TScrollLocation): void\n}\n\nexport const GroupedVirtuoso = forwardRef<GroupedVirtuosoMethods, GroupedVirtuosoProps>((props, ref) => {\n  const [state] = useState(VirtuosoStore(props))\n  useImperativeHandle(\n    ref,\n    () => ({\n      scrollToIndex: (location: TScrollLocation) => {\n        state.scrollToIndex(location)\n      },\n    }),\n    [state]\n  )\n\n  useEffect(() => {\n    state.startReached(props.startReached)\n    state.endReached(props.endReached)\n    state.rangeChanged(props.rangeChanged)\n    state.atBottomStateChange(props.atBottomStateChange)\n    state.isScrolling(props.scrollingStateChange)\n    state.groupCounts(props.groupCounts)\n    state.groupIndices(props.groupIndices)\n    state.itemsRendered(props.itemsRendered)\n    state.totalListHeightChanged(props.totalListHeightChanged)\n    state.renderProp(props.item)\n    state.groupRenderProp(props.group)\n    state.itemContainer(props.ItemContainer || 'div')\n    state.groupContainer(props.GroupContainer || 'div')\n    state.scrollSeekConfiguration(props.scrollSeek)\n\n    return () => {\n      state.itemsRendered(undefined)\n      state.totalListHeightChanged(undefined)\n    }\n  }, [\n    state,\n    props.startReached,\n    props.endReached,\n    props.rangeChanged,\n    props.atBottomStateChange,\n    props.scrollingStateChange,\n    props.groupCounts,\n    props.groupIndices,\n    props.itemsRendered,\n    props.totalListHeightChanged,\n    props.item,\n    props.group,\n    props.GroupContainer,\n    props.ItemContainer,\n    props.scrollSeek,\n  ])\n\n  return (\n    <VirtuosoPresentation\n      contextValue={state}\n      style={props.style}\n      className={props.className}\n      header={props.header}\n      footer={props.footer}\n      itemHeight={props.itemHeight}\n      ScrollContainer={props.ScrollContainer}\n      HeaderContainer={props.HeaderContainer}\n      FooterContainer={props.FooterContainer}\n      ListContainer={props.ListContainer}\n    />\n  )\n})\n\nGroupedVirtuoso.displayName = 'GroupedVirtuoso'\n","import * as React from 'react'\nimport { subject, map, combineLatest, withLatestFrom, coldSubject } from './tinyrx'\nimport { makeInput, makeOutput } from './rxio'\nimport { TScrollLocation, TContainer, buildIsScrolling } from './EngineCommons'\nimport { ListRange, scrollSeekEngine } from './engines/scrollSeekEngine'\n\ntype GridDimensions = [\n  number, // container width,\n  number, // container height,\n  number | undefined, // item container width,\n  number | undefined, // item container height\n  number | undefined, // item content width\n  number | undefined // item content height\n]\n\ntype GridItemRange = [\n  number, // start index\n  number // end index\n]\n\ntype GridItemsRenderer = (\n  item: (index: number) => React.ReactElement,\n  itemClassName: string,\n  ItemContainer: TContainer,\n  computeItemKey: (index: number) => number\n) => React.ReactElement[]\n\nconst { ceil, floor, min, max } = Math\n\nconst hackFloor = (val: number) => (ceil(val) - val < 0.03 ? ceil(val) : floor(val))\n\nexport const VirtuosoGridEngine = (initialItemCount = 0) => {\n  const itemsRender = subject<any>(false)\n  const gridDimensions$ = subject<GridDimensions>([0, 0, undefined, undefined, undefined, undefined])\n  const totalCount$ = subject(0)\n  const scrollTop$ = subject(0)\n  const overscan$ = subject(0)\n  const itemRange$ = subject<GridItemRange>([0, max(initialItemCount - 1, 0)])\n  const remainingHeight$ = subject(0)\n  const listOffset$ = subject(0)\n  const scrollToIndex$ = coldSubject<TScrollLocation>()\n  const rangeChanged$ = coldSubject<ListRange>()\n\n  combineLatest(gridDimensions$, scrollTop$, overscan$, totalCount$)\n    .pipe(withLatestFrom(itemRange$))\n    .subscribe(\n      ([[[viewportWidth, viewportHeight, itemWidth, itemHeight], scrollTop, overscan, totalCount], itemRange]) => {\n        if (itemWidth === undefined || itemHeight === undefined) {\n          return\n        }\n\n        if (totalCount === 0) {\n          itemRange$.next([0, -1])\n          listOffset$.next(0)\n          rangeChanged$.next({ startIndex: 0, endIndex: -1 })\n          return\n        }\n\n        const [startIndex, endIndex] = itemRange\n        const itemsPerRow = hackFloor(viewportWidth / itemWidth)\n\n        const toRowIndex = (index: number, roundFunc = floor) => {\n          return roundFunc(index / itemsPerRow)\n        }\n\n        const updateRange = (down: boolean): void => {\n          const [topOverscan, bottomOverscan] = down ? [0, overscan] : [overscan, 0]\n\n          let startIndex = itemsPerRow * floor((scrollTop - topOverscan) / itemHeight)\n\n          let endIndex = itemsPerRow * ceil((scrollTop + viewportHeight + bottomOverscan) / itemHeight) - 1\n\n          endIndex = min(totalCount - 1, endIndex)\n          startIndex = min(endIndex, max(0, startIndex))\n\n          itemRange$.next([startIndex, endIndex])\n          listOffset$.next(toRowIndex(startIndex) * itemHeight)\n          rangeChanged$.next({ startIndex, endIndex })\n        }\n\n        const listTop = itemHeight * toRowIndex(startIndex)\n        const listBottom = itemHeight * toRowIndex(endIndex) + itemHeight\n\n        // totalCount has decreased, we have to re-render\n        if (totalCount < endIndex - 1) {\n          updateRange(true)\n          // user is scrolling up - list top is below the top edge of the viewport\n        } else if (listTop > scrollTop) {\n          updateRange(false)\n          // user is scrolling down - list bottom is above the bottom edge of the viewport\n        } else if (listBottom < scrollTop + viewportHeight) {\n          updateRange(true)\n        }\n\n        remainingHeight$.next(itemHeight * toRowIndex(totalCount - endIndex - 1, ceil))\n      }\n    )\n\n  const scrollTo$ = scrollToIndex$.pipe(\n    withLatestFrom(gridDimensions$, totalCount$),\n    map(([location, [viewportWidth, viewportHeight, itemWidth, itemHeight], totalCount]) => {\n      if (itemWidth === undefined || itemHeight === undefined) {\n        return { top: 0, behavior: 'auto' } as ScrollOptions\n      }\n\n      if (typeof location === 'number') {\n        location = { index: location, align: 'start' }\n      }\n\n      let { index, align = 'start', behavior = 'auto' } = location\n\n      index = Math.max(0, index, Math.min(totalCount - 1, index))\n\n      const itemsPerRow = hackFloor(viewportWidth / itemWidth)\n\n      let offset = floor(index / itemsPerRow) * itemHeight\n\n      if (align === 'end') {\n        offset = offset - viewportHeight + itemHeight\n      } else if (align === 'center') {\n        offset = Math.round(offset - viewportHeight / 2 + itemHeight / 2)\n      }\n\n      return { top: offset, behavior } as ScrollToOptions\n    })\n  )\n\n  const isScrolling$ = buildIsScrolling(scrollTop$)\n\n  const endReached$ = coldSubject<number>()\n  let currentEndIndex = 0\n\n  itemRange$.pipe(withLatestFrom(totalCount$)).subscribe(([[_, endIndex], totalCount]) => {\n    if (totalCount === 0) {\n      return\n    }\n\n    if (endIndex === totalCount - 1) {\n      if (currentEndIndex !== endIndex) {\n        currentEndIndex = endIndex\n        endReached$.next(endIndex)\n      }\n    }\n  })\n\n  const { isSeeking$, scrollSeekConfiguration$ } = scrollSeekEngine({\n    scrollTop$,\n    isScrolling$,\n    rangeChanged$,\n  })\n\n  combineLatest(itemRange$, isSeeking$, scrollSeekConfiguration$, gridDimensions$)\n    .pipe(\n      map(([[startIndex, endIndex], renderPlaceholder, scrollSeek, [_, __, ___, ____, _____, itemHeight]]) => {\n        const render: GridItemsRenderer = (item, itemClassName, ItemContainer, computeItemKey) => {\n          const items = []\n          for (let index = startIndex; index <= endIndex; index++) {\n            const key = computeItemKey(index)\n            let children: React.ReactElement\n\n            if (scrollSeek && renderPlaceholder && itemHeight) {\n              children = React.createElement(scrollSeek.placeholder, {\n                height: itemHeight,\n                index,\n              })\n            } else {\n              children = item(index)\n            }\n\n            items.push(\n              React.createElement(\n                ItemContainer,\n                {\n                  key,\n                  className: itemClassName,\n                },\n                children\n              )\n            )\n          }\n\n          return items\n        }\n        return { render }\n      })\n    )\n    .subscribe(itemsRender.next)\n\n  return {\n    gridDimensions: makeInput(gridDimensions$),\n    totalCount: makeInput(totalCount$),\n    scrollTop: makeInput(scrollTop$),\n    overscan: makeInput(overscan$),\n    scrollToIndex: makeInput(scrollToIndex$),\n    scrollSeekConfiguration: makeInput(scrollSeekConfiguration$),\n\n    itemsRender: makeOutput(itemsRender),\n\n    itemRange: makeOutput(itemRange$),\n    remainingHeight: makeOutput(remainingHeight$),\n    listOffset: makeOutput(listOffset$),\n    scrollTo: makeOutput(scrollTo$),\n    isScrolling: makeOutput(isScrolling$),\n    endReached: makeOutput(endReached$),\n    rangeChanged: makeOutput(rangeChanged$),\n  }\n}\n","import * as React from 'react'\nimport { CSSProperties, ReactElement } from 'react'\nimport { TSubscriber } from './tinyrx'\nimport { VirtuosoGridEngine } from './VirtuosoGridEngine'\nimport { VirtuosoScroller, TScrollContainer } from './VirtuosoScroller'\nimport { useOutput, useSize } from './Utils'\nimport { viewportStyle } from './Style'\nimport { TScrollLocation, TContainer } from './EngineCommons'\nimport { ListRange, ScrollSeekConfiguration } from './engines/scrollSeekEngine'\n\nexport interface VirtuosoGridProps {\n  totalCount: number\n  overscan?: number\n  item: (index: number) => ReactElement\n  style?: CSSProperties\n  className?: string\n  ScrollContainer?: TScrollContainer\n  ListContainer?: TContainer\n  ItemContainer?: TContainer\n  listClassName?: string\n  itemClassName?: string\n  scrollingStateChange?: (isScrolling: boolean) => void\n  endReached?: (index: number) => void\n  initialItemCount?: number\n  rangeChanged?: TSubscriber<ListRange>\n  computeItemKey?: (index: number) => number\n  scrollSeek?: ScrollSeekConfiguration\n}\n\ntype VirtuosoGridState = ReturnType<typeof VirtuosoGridEngine>\n\ntype VirtuosoGridFCProps = Omit<VirtuosoGridProps, 'overscan' | 'totalCount'> & { engine: VirtuosoGridState }\n\nexport class VirtuosoGrid extends React.PureComponent<VirtuosoGridProps, VirtuosoGridState> {\n  public state = VirtuosoGridEngine(this.props.initialItemCount)\n\n  public static getDerivedStateFromProps(props: VirtuosoGridProps, engine: VirtuosoGridState) {\n    engine.overscan(props.overscan || 0)\n    engine.totalCount(props.totalCount)\n    engine.isScrolling(props.scrollingStateChange)\n    engine.endReached(props.endReached)\n    engine.rangeChanged(props.rangeChanged)\n    engine.scrollSeekConfiguration(props.scrollSeek)\n    return null\n  }\n\n  public scrollToIndex(location: TScrollLocation) {\n    this.state.scrollToIndex(location)\n  }\n\n  public render() {\n    return <VirtuosoGridFC {...this.props} engine={this.state} />\n  }\n}\n\nconst VirtuosoGridFC: React.FC<VirtuosoGridFCProps> = ({\n  ScrollContainer,\n  ItemContainer = 'div',\n  ListContainer = 'div',\n  className,\n  item,\n  itemClassName = 'virtuoso-grid-item',\n  listClassName = 'virtuoso-grid-list',\n  engine,\n  style = { height: '100%' },\n  computeItemKey = key => key,\n}) => {\n  const { listOffset, remainingHeight, gridDimensions, scrollTo, scrollTop, itemsRender } = engine\n\n  const fillerHeight = useOutput<number>(remainingHeight, 0)\n  const translate = useOutput<number>(listOffset, 0)\n  const listStyle = { paddingTop: `${translate}px`, paddingBottom: `${fillerHeight}px` }\n\n  const render = useOutput(itemsRender, false)\n\n  const viewportCallbackRef = useSize(({ element, width, height }) => {\n    const firstItem = element.firstChild!.firstChild as HTMLElement\n    const firstItemContent = firstItem!.firstChild as HTMLElement\n    gridDimensions([\n      width,\n      height,\n      firstItem.offsetWidth,\n      firstItem.offsetHeight,\n      firstItemContent.offsetWidth,\n      firstItemContent.offsetHeight,\n    ])\n  })\n\n  return (\n    <VirtuosoScroller\n      style={style}\n      ScrollContainer={ScrollContainer}\n      className={className}\n      scrollTo={scrollTo}\n      scrollTop={scrollTop}\n    >\n      <div ref={viewportCallbackRef} style={viewportStyle}>\n        {React.createElement(\n          ListContainer,\n          {\n            style: listStyle,\n            className: listClassName,\n          },\n          render.render(item, itemClassName, ItemContainer, computeItemKey)\n        )}\n      </div>\n    </VirtuosoScroller>\n  )\n}\n"],"names":["VirtuosoContext","createContext","undefined","combineOperators","operators","length","value","subscriber","acc","slice","reverse","forEach","operator","prevCallback","buildPipe","subscribe","observable","source","val","pipe","subject","initial","distinct","subscribers","push","filter","sub","next","newVal","coldSubject","combineLatest","sources","called","Array","fill","values","publish","every","isCalled","index","map","mapTo","_","done","skip","times","predicate","duc","comparator","current","scan","scanner","initialValue","prevVal","withLatestFrom","buildIsScrolling","scrollTop$","timeout","isScrolling$","clearTimeout","setTimeout","NIL_NODE","rebalance","this","adjust","shift","remove","find","findWith","findMax","Infinity","findMaxValue","insert","key","NonNilNode","level","walkWithin","walk","ranges","rangesWithin","empty","isSingle","isInvariant","keys","Object","freeze","UnreachableCaseError","_Error","Error","left","right","amount","clone","last","deleteLast","callback","result","rightKey","rightValue","start","end","concat","args","skew","split","rl","rightLevel","toRanges","startIndex","endIndex","nodes","first","i","nextNode","AATree","root","defaultValue","adjustedStart","StubIndexTransposer","transpose","items","item","groupIndex","offset","size","transposedIndex","type","GroupIndexTransposer","counts","count","reduce","groupCount","tree","total","totalCount","groupMatch","_this","groupIndices","getListTop","OffsetList","rangeTree","offsetTree","nanIndices","initialTopMostItemIndex","nanFound","rangeSize","isNaN","create","fromTree","maxRangeSize","rangeSizeExceededCallback","getDefaultSize","indexOf","overlapingRanges","some","range","firstPassDone","shouldInsert","rangeStart","rangeEnd","rangeValue","insertSpots","spotIndexes","spot","NaN","offsetOf","offsetRange","itemAt","indexRange","Math","max","min","startOffset","endOffset","minIndex","maxIndex","rangeOffset","rangeIndex","floor","getOffsets","indices","IndexList","setInitialIndex","topMostItemIndex","adjustForPrependedItems","configureMaxRangeSize","maxRangeSizeExceededCallback","scrollSeekEngine","range$","rangeChanged$","scrollVelocity$","isSeeking$","scrollSeekConfiguration$","speed","config","isSeeking","enter","exit","change","makeOutput","unsubscribe","makeInput","VirtuosoStore","overscan","itemHeight","defaultItemHeight","transposer$","viewportHeight$","topList$","topListHeight$","minListIndex$","topList","topListEngine","headerHeight$","footerHeight$","totalCount$","itemHeights$","initialItemCount$","pendingRenderAfterInitial$","unsubscribeInitial","initialItemCountEngine","heightsChanged$","initialOffsetList","offsetList$","stickyItems$","stickyItemsIndexList$","params","offsetList","transposer","currentStickyItem","stickyItemsEngine","totalHeight$","headerHeight","footerHeight","heights","stickyItems","pendingRenderAfterInitial","newList","offsetListEngine","groupCounts$","groupIndices$","groupCountEngine","scrolledToBottom$","notAtBottom","viewportHeight","totalHeight","scrolledToBottomEngine","scrollToIndex$","scrollToIndexRequestPending$","scrollTopReportedAfterScrollToIndex$","scrollTo$","scrolledToTopMostItem$","top","initialTopMostItemIndexEngine","location","topListHeight","align","behavior","round","scrollToIndexEngine","listHeight$","startReached$","endReached$","list$","constrainedScrollTop$","scrollTop","listHeight","scrolledToTopMostItem","itemLength","listTop","listBottom","listOffset$","currentEndIndex","listEngine","adjustForPrependedItems$","adjustmentInProgress$","adjustForPrependedItemsEngine","maxRangeSize$","scheduledReadjust$","list","scrollTo","maxRangeSizeEngine","topItemCount$","topItemCountEngine","followOutput$","followOutputEngine","stickyItemsOffset$","domTotalHeight$","scrollTopMultiplier$","domTotalHeight","domScrollTop$","domListOffset$","computeItemKey$","itemIndex","renderProp$","_groupIndex","groupRenderProp$","itemContainer$","groupContainer$","itemRender$","dataKey$","Symbol","render","groupRender","scrollSeek","computeItemKey","ItemContainer","GroupContainer","children","renderPlaceholder","itemProps","React","placeholder","height","groupCounts","itemHeights","topItemCount","scrollToIndex","initialItemCount","followOutput","scrollSeekConfiguration","renderProp","groupRenderProp","itemContainer","groupContainer","dataKey","itemRender","scrollVelocity","itemsRendered","listOffset","startReached","endReached","atBottomStateChange","totalListHeightChanged","rangeChanged","isScrolling","stickyItemsOffset","viewportStyle","position","width","useHeight","input","onMount","onResize","ref","useRef","animationFrameID","observer","ResizeObserver","entries","newHeight","contentRect","window","requestAnimationFrame","element","target","document","body","contains","useEffect","cancelAnimationFrame","elRef","observe","unobserve","useOutput","output","useState","callbackToValue","setValue","simpleMemoize","func","positionStickyCssValue","node","createElement","style","VirtuosoFiller","VirtuosoList","emptyComponent","useContext","topItems","renderedItems","topOffset","renderedTopItemIndices","marginTop","zIndex","scrollerStyle","overflowY","WebkitOverflowScrolling","outline","DefaultScrollContainer","className","reportScrollTop","smoothScrollTarget","currentScrollTop","onScroll","useCallback","e","theRef","addEventListener","passive","removeEventListener","tabIndex","VirtuosoScroller","ScrollContainer","DefaultHeaderContainer","headerRef","DefaultFooterContainer","footerRef","DefaultListContainer","listRef","VirtuosoHeader","header","HeaderContainer","headerCallbackRef","VirtuosoFooter","footer","FooterContainer","footerCallbackRef","ListWrapper","fixedItemHeight","ListContainer","listCallbackRef","measuredItemHeights","results","len","child","dataset","parseInt","knownSize","offsetHeight","lastResult","getHeights","VirtuosoView","fillerHeight","viewportCallbackRef","st","DEFAULT_STYLE","VirtuosoPresentation","Provider","contextValue","Virtuoso","forwardRef","props","state","useImperativeHandle","scrollingStateChange","maxHeightCacheSize","displayName","GroupedVirtuoso","group","ceil","hackFloor","VirtuosoGridEngine","itemsRender","gridDimensions$","overscan$","itemRange$","remainingHeight$","viewportWidth","itemWidth","itemRange","itemsPerRow","toRowIndex","roundFunc","updateRange","down","bottomOverscan","itemClassName","gridDimensions","remainingHeight","VirtuosoGrid","getDerivedStateFromProps","engine","VirtuosoGridFC","currentSize","listClassName","listStyle","paddingTop","paddingBottom","firstItem","firstChild","firstItemContent","offsetWidth"],"mappings":"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"}